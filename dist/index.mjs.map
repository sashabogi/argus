{"version":3,"sources":["../src/core/config.ts","../src/core/snapshot.ts","../src/core/engine.ts","../src/core/prompts.ts","../src/providers/openai-compatible.ts","../src/providers/ollama.ts","../src/providers/anthropic.ts","../src/providers/index.ts","../src/worker/server.ts","../src/worker/cache.ts","../src/worker/watcher.ts"],"sourcesContent":["/**\n * Argus Configuration Management\n * \n * Handles loading, saving, and validating configuration for Argus.\n * Configuration is stored in ~/.argus/config.json\n */\n\nimport { existsSync, mkdirSync, readFileSync, writeFileSync } from 'fs';\nimport { homedir } from 'os';\nimport { join } from 'path';\nimport type { OnboardingConfig, ProjectOnboardingConfig } from './onboarding.js';\n\nexport type ProviderType = 'zai' | 'anthropic' | 'openai' | 'deepseek' | 'ollama';\n\n// Re-export onboarding types\nexport type { OnboardingConfig, ProjectOnboardingConfig } from './onboarding.js';\n\nexport interface ProviderConfig {\n  apiKey?: string;\n  baseUrl?: string;\n  model: string;\n  options?: Record<string, unknown>;\n}\n\nexport interface ArgusConfig {\n  provider: ProviderType;\n  providers: {\n    zai?: ProviderConfig;\n    anthropic?: ProviderConfig;\n    openai?: ProviderConfig;\n    deepseek?: ProviderConfig;\n    ollama?: ProviderConfig;\n  };\n  defaults: {\n    maxTurns: number;\n    turnTimeoutMs: number;\n    snapshotExtensions: string[];\n    excludePatterns: string[];\n  };\n  onboarding?: OnboardingConfig;\n  onboardingComplete?: boolean;\n}\n\nconst DEFAULT_CONFIG: ArgusConfig = {\n  provider: 'ollama',\n  providers: {\n    ollama: {\n      baseUrl: 'http://localhost:11434',\n      model: 'qwen2.5-coder:7b',\n    },\n  },\n  defaults: {\n    maxTurns: 15,\n    turnTimeoutMs: 60000,\n    snapshotExtensions: ['ts', 'tsx', 'js', 'jsx', 'rs', 'py', 'go', 'java', 'rb', 'php', 'swift', 'kt', 'scala', 'c', 'cpp', 'h', 'hpp', 'cs', 'md'],\n    excludePatterns: [\n      'node_modules',\n      '.git',\n      'target',\n      'dist',\n      'build',\n      '.next',\n      'coverage',\n      '__pycache__',\n      '.venv',\n      'vendor',\n    ],\n  },\n};\n\nexport function getConfigDir(): string {\n  return join(homedir(), '.argus');\n}\n\nexport function getConfigPath(): string {\n  return join(getConfigDir(), 'config.json');\n}\n\nexport function ensureConfigDir(): void {\n  const dir = getConfigDir();\n  if (!existsSync(dir)) {\n    mkdirSync(dir, { recursive: true });\n  }\n}\n\nexport function loadConfig(): ArgusConfig {\n  const configPath = getConfigPath();\n  \n  if (!existsSync(configPath)) {\n    return DEFAULT_CONFIG;\n  }\n  \n  try {\n    const content = readFileSync(configPath, 'utf-8');\n    const loaded = JSON.parse(content) as Partial<ArgusConfig>;\n    \n    // Merge with defaults\n    return {\n      ...DEFAULT_CONFIG,\n      ...loaded,\n      providers: {\n        ...DEFAULT_CONFIG.providers,\n        ...loaded.providers,\n      },\n      defaults: {\n        ...DEFAULT_CONFIG.defaults,\n        ...loaded.defaults,\n      },\n    };\n  } catch {\n    // Silently return defaults - don't console.error as it can corrupt MCP JSON streams\n    return DEFAULT_CONFIG;\n  }\n}\n\nexport function saveConfig(config: ArgusConfig): void {\n  ensureConfigDir();\n  const configPath = getConfigPath();\n  writeFileSync(configPath, JSON.stringify(config, null, 2));\n}\n\nexport function getProviderConfig(config: ArgusConfig): ProviderConfig {\n  const providerConfig = config.providers[config.provider];\n  \n  if (!providerConfig) {\n    throw new Error(`No configuration found for provider: ${config.provider}`);\n  }\n  \n  return providerConfig;\n}\n\nexport function validateConfig(config: ArgusConfig): string[] {\n  const errors: string[] = [];\n  \n  const providerConfig = config.providers[config.provider];\n  \n  if (!providerConfig) {\n    errors.push(`Provider \"${config.provider}\" is not configured`);\n    return errors;\n  }\n  \n  // Ollama doesn't need an API key\n  if (config.provider !== 'ollama' && !providerConfig.apiKey) {\n    errors.push(`API key is required for provider \"${config.provider}\"`);\n  }\n  \n  if (!providerConfig.model) {\n    errors.push(`Model is required for provider \"${config.provider}\"`);\n  }\n  \n  return errors;\n}\n\nexport const PROVIDER_DEFAULTS: Record<ProviderType, Partial<ProviderConfig>> = {\n  zai: {\n    baseUrl: 'https://api.z.ai/api/coding/paas/v4',\n    model: 'glm-4.7',\n  },\n  anthropic: {\n    baseUrl: 'https://api.anthropic.com',\n    model: 'claude-sonnet-4-20250514',\n  },\n  openai: {\n    baseUrl: 'https://api.openai.com/v1',\n    model: 'gpt-4o',\n  },\n  deepseek: {\n    baseUrl: 'https://api.deepseek.com',\n    model: 'deepseek-chat',\n  },\n  ollama: {\n    baseUrl: 'http://localhost:11434',\n    model: 'qwen2.5-coder:7b',\n  },\n};\n","/**\n * Argus Snapshot Generator\n * \n * Creates optimized text snapshots of codebases for analysis.\n * Handles file filtering, exclusion patterns, and formatting.\n */\n\nimport { existsSync, readFileSync, readdirSync, statSync, writeFileSync } from 'fs';\nimport { join, relative, extname } from 'path';\n\nexport interface SnapshotOptions {\n  extensions?: string[];\n  excludePatterns?: string[];\n  maxFileSize?: number; // in bytes\n  includeHidden?: boolean;\n}\n\nexport interface SnapshotResult {\n  outputPath: string;\n  fileCount: number;\n  totalLines: number;\n  totalSize: number;\n  files: string[];\n}\n\nconst DEFAULT_OPTIONS: Required<SnapshotOptions> = {\n  extensions: ['ts', 'tsx', 'js', 'jsx', 'rs', 'py', 'go', 'java', 'rb', 'php', 'swift', 'kt', 'scala', 'c', 'cpp', 'h', 'hpp', 'cs', 'md', 'json'],\n  excludePatterns: [\n    'node_modules',\n    '.git',\n    'target',\n    'dist',\n    'build',\n    '.next',\n    'coverage',\n    '__pycache__',\n    '.venv',\n    'vendor',\n    '.DS_Store',\n    '*.lock',\n    'package-lock.json',\n    '*.min.js',\n    '*.min.css',\n  ],\n  maxFileSize: 1024 * 1024, // 1MB\n  includeHidden: false,\n};\n\nfunction shouldExclude(filePath: string, patterns: string[]): boolean {\n  const normalizedPath = filePath.replace(/\\\\/g, '/');\n  \n  for (const pattern of patterns) {\n    // Glob-like pattern matching\n    if (pattern.startsWith('*')) {\n      const suffix = pattern.slice(1);\n      if (normalizedPath.endsWith(suffix)) return true;\n    } else if (normalizedPath.includes(`/${pattern}/`) || normalizedPath.endsWith(`/${pattern}`) || normalizedPath === pattern) {\n      return true;\n    }\n  }\n  \n  return false;\n}\n\nfunction hasValidExtension(filePath: string, extensions: string[]): boolean {\n  const ext = extname(filePath).slice(1).toLowerCase();\n  return extensions.includes(ext);\n}\n\nfunction collectFiles(\n  dir: string,\n  options: Required<SnapshotOptions>,\n  baseDir: string = dir\n): string[] {\n  const files: string[] = [];\n  \n  try {\n    const entries = readdirSync(dir, { withFileTypes: true });\n    \n    for (const entry of entries) {\n      const fullPath = join(dir, entry.name);\n      const relativePath = relative(baseDir, fullPath);\n      \n      // Skip hidden files unless explicitly included\n      if (!options.includeHidden && entry.name.startsWith('.')) {\n        continue;\n      }\n      \n      // Check exclusion patterns\n      if (shouldExclude(relativePath, options.excludePatterns)) {\n        continue;\n      }\n      \n      if (entry.isDirectory()) {\n        files.push(...collectFiles(fullPath, options, baseDir));\n      } else if (entry.isFile()) {\n        // Check extension\n        if (!hasValidExtension(entry.name, options.extensions)) {\n          continue;\n        }\n        \n        // Check file size\n        try {\n          const stats = statSync(fullPath);\n          if (stats.size > options.maxFileSize) {\n            continue;\n          }\n        } catch {\n          continue;\n        }\n        \n        files.push(fullPath);\n      }\n    }\n  } catch (error) {\n    // Directory not readable, skip\n  }\n  \n  return files.sort();\n}\n\nexport function createSnapshot(\n  projectPath: string,\n  outputPath: string,\n  options: SnapshotOptions = {}\n): SnapshotResult {\n  const mergedOptions: Required<SnapshotOptions> = {\n    ...DEFAULT_OPTIONS,\n    ...options,\n  };\n  \n  if (!existsSync(projectPath)) {\n    throw new Error(`Project path does not exist: ${projectPath}`);\n  }\n  \n  const stats = statSync(projectPath);\n  if (!stats.isDirectory()) {\n    throw new Error(`Project path is not a directory: ${projectPath}`);\n  }\n  \n  // Collect all files\n  const files = collectFiles(projectPath, mergedOptions);\n  \n  // Build snapshot content\n  const lines: string[] = [];\n  \n  // Header\n  lines.push('================================================================================');\n  lines.push('CODEBASE SNAPSHOT');\n  lines.push(`Project: ${projectPath}`);\n  lines.push(`Generated: ${new Date().toISOString()}`);\n  lines.push(`Extensions: ${mergedOptions.extensions.join(', ')}`);\n  lines.push(`Files: ${files.length}`);\n  lines.push('================================================================================');\n  lines.push('');\n  \n  // Process each file\n  for (const filePath of files) {\n    const relativePath = relative(projectPath, filePath);\n    \n    lines.push('');\n    lines.push('================================================================================');\n    lines.push(`FILE: ./${relativePath}`);\n    lines.push('================================================================================');\n    \n    try {\n      const content = readFileSync(filePath, 'utf-8');\n      lines.push(content);\n    } catch (error) {\n      lines.push('[Unable to read file]');\n    }\n  }\n  \n  // Write snapshot\n  const content = lines.join('\\n');\n  writeFileSync(outputPath, content);\n  \n  const totalLines = content.split('\\n').length;\n  const totalSize = Buffer.byteLength(content, 'utf-8');\n  \n  return {\n    outputPath,\n    fileCount: files.length,\n    totalLines,\n    totalSize,\n    files: files.map(f => relative(projectPath, f)),\n  };\n}\n\nexport function getSnapshotStats(snapshotPath: string): {\n  fileCount: number;\n  totalLines: number;\n  totalSize: number;\n} {\n  if (!existsSync(snapshotPath)) {\n    throw new Error(`Snapshot file does not exist: ${snapshotPath}`);\n  }\n  \n  const content = readFileSync(snapshotPath, 'utf-8');\n  const totalLines = content.split('\\n').length;\n  const totalSize = Buffer.byteLength(content, 'utf-8');\n  \n  // Count FILE: markers\n  const fileMatches = content.match(/^FILE: /gm);\n  const fileCount = fileMatches ? fileMatches.length : 0;\n  \n  return { fileCount, totalLines, totalSize };\n}\n","/**\n * Argus RLM Engine\n * \n * Recursive Language Model engine for document analysis.\n * Based on the Matryoshka RLM approach by Dmitri Sotnikov.\n * \n * The engine uses an LLM to generate Nucleus DSL commands that are\n * executed against documents, enabling analysis of content far\n * exceeding typical context limits.\n */\n\nimport { readFileSync } from 'fs';\nimport { AIProvider, Message } from '../providers/types.js';\nimport { buildSystemPrompt, getTurnLimit } from './prompts.js';\n\nexport interface AnalysisOptions {\n  maxTurns?: number;\n  turnTimeoutMs?: number;\n  verbose?: boolean;\n  onProgress?: (turn: number, command: string, result: unknown) => void;\n}\n\nexport interface AnalysisResult {\n  answer: string;\n  turns: number;\n  commands: string[];\n  success: boolean;\n  error?: string;\n}\n\ninterface GrepMatch {\n  match: string;\n  line: string;\n  lineNum: number;\n  index: number;\n  groups: string[];\n}\n\nconst NUCLEUS_REFERENCE = `\nYou are analyzing a document using the Nucleus DSL. Generate S-expression commands to explore the document.\n\nAVAILABLE COMMANDS:\n- (grep \"pattern\") - Search for regex pattern, returns matches with line numbers\n- (grep \"pattern\" \"flags\") - With flags like \"i\" for case-insensitive\n- (count RESULTS) - Count number of items in RESULTS\n- (map RESULTS (lambda (x) expr)) - Transform each item\n- (filter RESULTS (lambda (x) expr)) - Keep items where expr is true\n- (sort RESULTS key) - Sort by key\n- (first RESULTS) - Get first item\n- (last RESULTS) - Get last item  \n- (take RESULTS n) - Get first n items\n- (match str \"pattern\" group) - Extract regex group from string\n\nVARIABLES:\n- RESULTS always contains the result of the last command\n- _1, _2, etc. contain results from turn 1, 2, etc.\n\nFINAL ANSWER:\nWhen you have enough information, output: <<<FINAL>>>your answer here<<<END>>>\n\nRULES:\n1. Output ONLY a single Nucleus command OR a final answer, nothing else\n2. Use grep to search the document\n3. Use map/filter to process results\n4. Build understanding iteratively\n5. When ready, provide the final answer\n\nExample session:\nTurn 1: (grep \"function.*export\")\nTurn 2: (count RESULTS)\nTurn 3: <<<FINAL>>>There are 15 exported functions<<<END>>>\n`;\n\n/**\n * Execute a Nucleus command against document content\n */\nfunction executeNucleus(command: string, content: string, bindings: Map<string, unknown>): unknown {\n  // Parse the S-expression\n  const parsed = parseSExpression(command);\n  if (!parsed) {\n    throw new Error(`Failed to parse command: ${command}`);\n  }\n  \n  return evaluateExpr(parsed, content, bindings);\n}\n\ntype SExpr = string | SExpr[];\n\nfunction parseSExpression(input: string): SExpr | null {\n  const tokens = tokenize(input.trim());\n  if (tokens.length === 0) return null;\n  \n  let pos = 0;\n  \n  function parse(): SExpr {\n    const token = tokens[pos++];\n    \n    if (token === '(') {\n      const list: SExpr[] = [];\n      while (tokens[pos] !== ')' && pos < tokens.length) {\n        list.push(parse());\n      }\n      pos++; // consume ')'\n      return list;\n    } else if (token.startsWith('\"')) {\n      // String literal\n      return token.slice(1, -1).replace(/\\\\\"/g, '\"');\n    } else if (/^-?\\d+(\\.\\d+)?$/.test(token)) {\n      return token; // Keep as string, convert when needed\n    } else {\n      return token; // Symbol\n    }\n  }\n  \n  return parse();\n}\n\nfunction tokenize(input: string): string[] {\n  const tokens: string[] = [];\n  let i = 0;\n  \n  while (i < input.length) {\n    const char = input[i];\n    \n    if (/\\s/.test(char)) {\n      i++;\n      continue;\n    }\n    \n    if (char === '(' || char === ')') {\n      tokens.push(char);\n      i++;\n      continue;\n    }\n    \n    if (char === '\"') {\n      let str = '\"';\n      i++;\n      while (i < input.length && input[i] !== '\"') {\n        if (input[i] === '\\\\' && i + 1 < input.length) {\n          str += input[i] + input[i + 1];\n          i += 2;\n        } else {\n          str += input[i];\n          i++;\n        }\n      }\n      str += '\"';\n      i++;\n      tokens.push(str);\n      continue;\n    }\n    \n    // Symbol or number\n    let sym = '';\n    while (i < input.length && !/[\\s()]/.test(input[i])) {\n      sym += input[i];\n      i++;\n    }\n    tokens.push(sym);\n  }\n  \n  return tokens;\n}\n\nfunction evaluateExpr(expr: SExpr, content: string, bindings: Map<string, unknown>): unknown {\n  if (typeof expr === 'string') {\n    // Variable lookup\n    if (bindings.has(expr)) {\n      return bindings.get(expr);\n    }\n    // Number\n    if (/^-?\\d+(\\.\\d+)?$/.test(expr)) {\n      return parseFloat(expr);\n    }\n    return expr;\n  }\n  \n  if (!Array.isArray(expr) || expr.length === 0) {\n    return expr;\n  }\n  \n  const [op, ...args] = expr;\n  \n  switch (op) {\n    case 'grep': {\n      const pattern = evaluateExpr(args[0], content, bindings) as string;\n      const flags = args[1] ? evaluateExpr(args[1], content, bindings) as string : '';\n      const regex = new RegExp(pattern, flags + 'g');\n      // Cache lines array to avoid re-splitting on every grep (major memory optimization)\n      let lines = bindings.get('__cached_lines__') as string[] | undefined;\n      if (!lines) {\n        lines = content.split('\\n');\n        bindings.set('__cached_lines__', lines);\n      }\n      const matches: GrepMatch[] = [];\n      const MAX_MATCHES = 1000; // Prevent memory explosion\n\n      let charIndex = 0;\n      for (let lineNum = 0; lineNum < lines.length; lineNum++) {\n        const line = lines[lineNum];\n        let match;\n        const lineRegex = new RegExp(pattern, flags + 'g');\n        while ((match = lineRegex.exec(line)) !== null) {\n          matches.push({\n            match: match[0],\n            line: line,\n            lineNum: lineNum + 1,\n            index: charIndex + match.index,\n            groups: match.slice(1),\n          });\n          if (matches.length >= MAX_MATCHES) {\n            return matches;\n          }\n        }\n        charIndex += line.length + 1;\n      }\n\n      return matches;\n    }\n    \n    case 'count': {\n      const arr = evaluateExpr(args[0], content, bindings);\n      if (Array.isArray(arr)) return arr.length;\n      return 0;\n    }\n    \n    case 'map': {\n      const arr = evaluateExpr(args[0], content, bindings) as unknown[];\n      const lambdaExpr = args[1] as SExpr[];\n      \n      if (!Array.isArray(lambdaExpr) || lambdaExpr[0] !== 'lambda') {\n        throw new Error('map requires a lambda expression');\n      }\n      \n      const params = lambdaExpr[1] as SExpr[];\n      const body = lambdaExpr[2];\n      const paramName = Array.isArray(params) ? params[0] as string : params as string;\n      \n      return arr.map(item => {\n        const localBindings = new Map(bindings);\n        localBindings.set(paramName, item);\n        return evaluateExpr(body, content, localBindings);\n      });\n    }\n    \n    case 'filter': {\n      const arr = evaluateExpr(args[0], content, bindings) as unknown[];\n      const lambdaExpr = args[1] as SExpr[];\n      \n      if (!Array.isArray(lambdaExpr) || lambdaExpr[0] !== 'lambda') {\n        throw new Error('filter requires a lambda expression');\n      }\n      \n      const params = lambdaExpr[1] as SExpr[];\n      const body = lambdaExpr[2];\n      const paramName = Array.isArray(params) ? params[0] as string : params as string;\n      \n      return arr.filter(item => {\n        const localBindings = new Map(bindings);\n        localBindings.set(paramName, item);\n        return evaluateExpr(body, content, localBindings);\n      });\n    }\n    \n    case 'first': {\n      const arr = evaluateExpr(args[0], content, bindings) as unknown[];\n      return arr[0];\n    }\n    \n    case 'last': {\n      const arr = evaluateExpr(args[0], content, bindings) as unknown[];\n      return arr[arr.length - 1];\n    }\n    \n    case 'take': {\n      const arr = evaluateExpr(args[0], content, bindings) as unknown[];\n      const n = evaluateExpr(args[1], content, bindings) as number;\n      return arr.slice(0, n);\n    }\n    \n    case 'sort': {\n      const arr = evaluateExpr(args[0], content, bindings) as Record<string, unknown>[];\n      const key = evaluateExpr(args[1], content, bindings) as string;\n      return [...arr].sort((a, b) => {\n        const aVal = a[key];\n        const bVal = b[key];\n        if (typeof aVal === 'number' && typeof bVal === 'number') {\n          return aVal - bVal;\n        }\n        return String(aVal).localeCompare(String(bVal));\n      });\n    }\n    \n    case 'match': {\n      const str = evaluateExpr(args[0], content, bindings);\n      const strValue = typeof str === 'object' && str !== null && 'line' in str \n        ? (str as GrepMatch).line \n        : String(str);\n      const pattern = evaluateExpr(args[1], content, bindings) as string;\n      const group = args[2] ? evaluateExpr(args[2], content, bindings) as number : 0;\n      \n      const regex = new RegExp(pattern);\n      const match = strValue.match(regex);\n      if (match) {\n        return match[group] || null;\n      }\n      return null;\n    }\n    \n    default:\n      throw new Error(`Unknown command: ${op}`);\n  }\n}\n\n/**\n * Extract Nucleus command from LLM response\n */\nfunction extractCommand(response: string): { command?: string; finalAnswer?: string } {\n  // Check for final answer\n  const finalMatch = response.match(/<<<FINAL>>>([\\s\\S]*?)<<<END>>>/);\n  if (finalMatch) {\n    return { finalAnswer: finalMatch[1].trim() };\n  }\n  \n  // Look for S-expression\n  const sexpMatch = response.match(/\\([^)]*(?:\\([^)]*\\)[^)]*)*\\)/);\n  if (sexpMatch) {\n    return { command: sexpMatch[0] };\n  }\n  \n  return {};\n}\n\n/**\n * Run RLM analysis on a document\n */\nexport async function analyze(\n  provider: AIProvider,\n  documentPath: string,\n  query: string,\n  options: AnalysisOptions = {}\n): Promise<AnalysisResult> {\n  const {\n    maxTurns = 15,\n    verbose = false,\n    onProgress,\n  } = options;\n  \n  // Use dynamic turn limit based on query type, but cap at maxTurns\n  const dynamicLimit = Math.min(getTurnLimit(query), maxTurns);\n  \n  // Load document\n  const content = readFileSync(documentPath, 'utf-8');\n\n  // Get document stats for context (count newlines without splitting)\n  const fileCount = (content.match(/^FILE:/gm) || []).length;\n  const lineCount = (content.match(/\\n/g) || []).length + 1;\n\n  const bindings = new Map<string, unknown>();\n  const commands: string[] = [];\n  const messages: Message[] = [\n    {\n      role: 'system',\n      content: buildSystemPrompt(query),\n    },\n    {\n      role: 'user',\n      content: `CODEBASE SNAPSHOT:\n- Total size: ${content.length.toLocaleString()} characters\n- Files: ${fileCount}\n- Lines: ${lineCount.toLocaleString()}\n\nFiles are marked with \"FILE: ./path/to/file\" headers.\n\nQUERY: ${query}\n\nBegin analysis. You have ${dynamicLimit} turns maximum - provide final answer before then.`,\n    },\n  ];\n  \n  for (let turn = 1; turn <= dynamicLimit; turn++) {\n    // Force final answer on last turn\n    const isLastTurn = turn === dynamicLimit;\n    const isNearEnd = turn >= dynamicLimit - 2;\n    \n    if (verbose) {\n      console.log(`\\n[Turn ${turn}/${dynamicLimit}] Querying LLM...`);\n    }\n    \n    // Get LLM response\n    const result = await provider.complete(messages);\n    const response = result.content;\n    \n    if (verbose) {\n      console.log(`[Turn ${turn}] Response: ${response.slice(0, 200)}...`);\n    }\n    \n    // Extract command or final answer\n    const extracted = extractCommand(response);\n    \n    if (extracted.finalAnswer) {\n      return {\n        answer: extracted.finalAnswer,\n        turns: turn,\n        commands,\n        success: true,\n      };\n    }\n    \n    if (!extracted.command) {\n      // No command found, add to messages and continue\n      messages.push({ role: 'assistant', content: response });\n      messages.push({ role: 'user', content: 'Please provide a Nucleus command or final answer.' });\n      continue;\n    }\n    \n    const command = extracted.command;\n    commands.push(command);\n    \n    if (verbose) {\n      console.log(`[Turn ${turn}] Command: ${command}`);\n    }\n    \n    // Execute command\n    try {\n      const cmdResult = executeNucleus(command, content, bindings);\n      \n      // Store result in bindings\n      bindings.set('RESULTS', cmdResult);\n      bindings.set(`_${turn}`, cmdResult);\n      \n      const resultStr = JSON.stringify(cmdResult, null, 2);\n      const truncatedResult = resultStr.length > 2000 \n        ? resultStr.slice(0, 2000) + '...[truncated]' \n        : resultStr;\n      \n      if (verbose) {\n        console.log(`[Turn ${turn}] Result: ${truncatedResult.slice(0, 500)}...`);\n      }\n      \n      onProgress?.(turn, command, cmdResult);\n      \n      // Add to conversation with nudge if near end\n      messages.push({ role: 'assistant', content: command });\n      \n      let userMessage = `Result:\\n${truncatedResult}`;\n      if (isNearEnd && !isLastTurn) {\n        userMessage += `\\n\\n⚠️ ${dynamicLimit - turn} turns remaining. Start forming your final answer.`;\n      }\n      messages.push({ role: 'user', content: userMessage });\n      \n      // FORCE final answer on last turn - make one more LLM call\n      if (isLastTurn) {\n        messages.push({ \n          role: 'user', \n          content: 'STOP SEARCHING. Based on everything you found, provide your final answer NOW using <<<FINAL>>>your answer<<<END>>>' \n        });\n        \n        const finalResult = await provider.complete(messages);\n        const finalExtracted = extractCommand(finalResult.content);\n        \n        if (finalExtracted.finalAnswer) {\n          return {\n            answer: finalExtracted.finalAnswer,\n            turns: turn,\n            commands,\n            success: true,\n          };\n        }\n        \n        // Even if not properly formatted, return whatever we got\n        return {\n          answer: finalResult.content,\n          turns: turn,\n          commands,\n          success: true,\n        };\n      }\n      \n    } catch (error) {\n      const errMsg = error instanceof Error ? error.message : String(error);\n      \n      if (verbose) {\n        console.log(`[Turn ${turn}] Error: ${errMsg}`);\n      }\n      \n      messages.push({ role: 'assistant', content: command });\n      messages.push({ role: 'user', content: `Error executing command: ${errMsg}` });\n    }\n  }\n  \n  return {\n    answer: 'Maximum turns reached without final answer',\n    turns: dynamicLimit,\n    commands,\n    success: false,\n    error: 'Max turns reached',\n  };\n}\n\n/**\n * Fast grep search without AI\n */\nexport function searchDocument(\n  documentPath: string,\n  pattern: string,\n  options: { caseInsensitive?: boolean; maxResults?: number } = {}\n): GrepMatch[] {\n  const content = readFileSync(documentPath, 'utf-8');\n  const flags = options.caseInsensitive ? 'gi' : 'g';\n  const regex = new RegExp(pattern, flags);\n  const lines = content.split('\\n');\n  const matches: GrepMatch[] = [];\n  \n  let charIndex = 0;\n  for (let lineNum = 0; lineNum < lines.length; lineNum++) {\n    const line = lines[lineNum];\n    let match;\n    const lineRegex = new RegExp(pattern, flags);\n    while ((match = lineRegex.exec(line)) !== null) {\n      matches.push({\n        match: match[0],\n        line: line,\n        lineNum: lineNum + 1,\n        index: charIndex + match.index,\n        groups: match.slice(1),\n      });\n      \n      if (options.maxResults && matches.length >= options.maxResults) {\n        return matches;\n      }\n    }\n    charIndex += line.length + 1;\n  }\n  \n  return matches;\n}\n","/**\n * Argus RLM Prompts\n * \n * Optimized prompts for codebase understanding that persists across Claude Code sessions.\n */\n\nexport const NUCLEUS_COMMANDS = `\nCOMMANDS (output ONE per turn):\n(grep \"pattern\")           - Find lines matching regex\n(grep \"pattern\" \"i\")       - Case-insensitive search  \n(count RESULTS)            - Count matches\n(take RESULTS n)           - First n results\n(filter RESULTS (lambda (x) (match x.line \"pattern\" 0)))  - Filter results\n(map RESULTS (lambda (x) x.line))  - Extract just the lines\n\nVARIABLES: RESULTS = last result, _1 _2 _3 = results from turn 1,2,3\n\nTO ANSWER: <<<FINAL>>>your answer<<<END>>>\n`;\n\n// Main system prompt for codebase analysis\nexport const CODEBASE_ANALYSIS_PROMPT = `You are analyzing a SOFTWARE CODEBASE snapshot to help a developer understand it.\n\nThe snapshot contains source files concatenated with \"FILE: ./path/to/file\" markers.\n\n${NUCLEUS_COMMANDS}\n\n## STRATEGY FOR CODEBASE SNAPSHOTS\n\n**To find modules/directories:**\n(grep \"FILE:.*src/[^/]+/\")       - top-level source dirs\n(grep \"FILE:.*mod\\\\.rs\")         - Rust modules  \n(grep \"FILE:.*index\\\\.(ts|js)\")  - JS/TS modules\n\n**To find implementations:**\n(grep \"fn function_name\")        - Rust functions\n(grep \"function|const.*=>\")      - JS functions\n(grep \"class ClassName\")         - Classes\n(grep \"struct |type |interface\") - Type definitions\n\n**To understand structure:**\n(grep \"FILE:\")                   - List all files\n(grep \"use |import |require\")    - Find dependencies\n(grep \"pub |export\")             - Public APIs\n\n## RULES\n1. Output ONLY a Nucleus command OR a final answer\n2. NO explanations, NO markdown formatting in commands\n3. MUST provide final answer by turn 8\n4. If turn 6+, start summarizing what you found\n\n## EXAMPLE SESSION\nTurn 1: (grep \"FILE:.*src/[^/]+/mod\\\\.rs\")\nTurn 2: (take RESULTS 15)\nTurn 3: <<<FINAL>>>The codebase has these main modules:\n- src/auth/ - Authentication handling\n- src/api/ - API endpoints\n- src/db/ - Database layer\n...<<<END>>>\n`;\n\n// Specialized prompt for architecture questions\nexport const ARCHITECTURE_PROMPT = `You are generating an ARCHITECTURE SUMMARY of a codebase.\n\n${NUCLEUS_COMMANDS}\n\n## YOUR TASK\nCreate a summary suitable for CLAUDE.md that helps Claude Code understand this project after context compaction.\n\n## SEARCH STRATEGY (do these in order)\n1. (grep \"FILE:.*mod\\\\.rs|FILE:.*index\\\\.(ts|js)\") - Find module entry points\n2. (take RESULTS 20) - Limit results\n3. Based on file paths, provide your summary\n\n## OUTPUT FORMAT\nYour final answer should be structured like:\n\n## Modules\n- **module_name/** - Brief description based on files found\n\n## Key Patterns  \n- Pattern observations from the code\n\n## Important Files\n- List key files and their apparent purpose\n\nPROVIDE FINAL ANSWER BY TURN 6.\n`;\n\n// Prompt for finding specific implementations\nexport const IMPLEMENTATION_PROMPT = `You are finding HOW something works in a codebase.\n\n${NUCLEUS_COMMANDS}\n\n## STRATEGY\n1. (grep \"FILE:.*keyword\") - Find files related to the concept\n2. (grep \"keyword\") - Find all mentions\n3. (take RESULTS 30) - Limit if too many results\n4. Look for function definitions, structs, classes\n5. PROVIDE FINAL ANSWER based on file paths and code patterns found\n\n## IMPORTANT\n- You have 12 turns maximum\n- By turn 8, START WRITING YOUR FINAL ANSWER\n- Use what you've found - don't keep searching indefinitely\n- It's better to give a partial answer than no answer\n\n## OUTPUT FORMAT\nYour final answer should explain:\n- Which files contain the implementation\n- Key functions/structs/classes involved  \n- Basic flow of how it works (based on what you found)\n`;\n\n// Prompt for counting/quantifying\nexport const COUNT_PROMPT = `You are counting items in a codebase.\n\n${NUCLEUS_COMMANDS}\n\n## STRATEGY  \n1. (grep \"pattern\")\n2. (count RESULTS)\n3. <<<FINAL>>>There are N items matching the pattern.<<<END>>>\n\nTHIS SHOULD TAKE 2-3 TURNS MAXIMUM.\n`;\n\n// Prompt for quick searches\nexport const SEARCH_PROMPT = `You are searching for specific code.\n\n${NUCLEUS_COMMANDS}\n\n## STRATEGY\n1. (grep \"pattern\")\n2. (take RESULTS 20) if too many\n3. Report what you found with file paths\n\nPROVIDE FINAL ANSWER BY TURN 4.\n`;\n\n/**\n * Detect query type and select best prompt\n */\nexport function selectPrompt(query: string): string {\n  const q = query.toLowerCase();\n  \n  // Count queries - fastest\n  if (/how many|count|number of|total|how much/.test(q)) {\n    return COUNT_PROMPT;\n  }\n  \n  // Simple search queries\n  if (/^(find|search|show|list|where is|locate)\\b/.test(q) && q.length < 50) {\n    return SEARCH_PROMPT;\n  }\n  \n  // Architecture/overview queries  \n  if (/architect|structure|overview|module|organization|main.*component|summar|layout/.test(q)) {\n    return ARCHITECTURE_PROMPT;\n  }\n  \n  // Implementation queries\n  if (/how does|how is|implement|work|handle|process|flow/.test(q)) {\n    return IMPLEMENTATION_PROMPT;\n  }\n  \n  // Default\n  return CODEBASE_ANALYSIS_PROMPT;\n}\n\n/**\n * Build system prompt with query-specific guidance\n */\nexport function buildSystemPrompt(query: string): string {\n  return selectPrompt(query);\n}\n\n/**\n * Get the turn limit based on query type\n */\nexport function getTurnLimit(query: string): number {\n  const q = query.toLowerCase();\n  \n  if (/how many|count/.test(q)) return 5;\n  if (/^(find|search|show|list)\\b/.test(q) && q.length < 50) return 6;\n  if (/architect|overview|structure|module/.test(q)) return 12;\n  if (/how does|how is|implement|work/.test(q)) return 12;  // Implementation needs more\n  \n  return 12; // Default\n}\n","/**\n * OpenAI-Compatible Provider\n * \n * Works with OpenAI, ZAI (GLM), DeepSeek, and any OpenAI-compatible API.\n */\n\nimport { AIProvider, Message, CompletionOptions, CompletionResult, ProviderConfig } from './types.js';\n\nexport class OpenAICompatibleProvider implements AIProvider {\n  name: string;\n  private config: ProviderConfig;\n  \n  constructor(name: string, config: ProviderConfig) {\n    this.name = name;\n    this.config = config;\n    \n    if (!config.apiKey) {\n      throw new Error(`API key is required for ${name} provider`);\n    }\n    \n    if (!config.baseUrl) {\n      throw new Error(`Base URL is required for ${name} provider`);\n    }\n  }\n  \n  async complete(messages: Message[], options?: CompletionOptions): Promise<CompletionResult> {\n    const endpoint = `${this.config.baseUrl}/chat/completions`;\n    \n    const body = {\n      model: this.config.model,\n      messages: messages.map(m => ({\n        role: m.role,\n        content: m.content,\n      })),\n      temperature: options?.temperature ?? this.config.options?.temperature ?? 0.2,\n      max_tokens: options?.maxTokens ?? this.config.options?.max_tokens ?? 4096,\n      ...(options?.stopSequences && { stop: options.stopSequences }),\n    };\n    \n    const response = await fetch(endpoint, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${this.config.apiKey}`,\n      },\n      body: JSON.stringify(body),\n    });\n    \n    if (!response.ok) {\n      const errorText = await response.text();\n      throw new Error(`${this.name} API error (${response.status}): ${errorText}`);\n    }\n    \n    const data = await response.json() as {\n      choices: Array<{\n        message: { content: string };\n        finish_reason: string;\n      }>;\n      usage?: {\n        prompt_tokens: number;\n        completion_tokens: number;\n        total_tokens: number;\n      };\n    };\n    \n    const choice = data.choices[0];\n    \n    return {\n      content: choice.message.content || '',\n      finishReason: choice.finish_reason === 'stop' ? 'stop' : \n                    choice.finish_reason === 'length' ? 'length' : 'error',\n      usage: data.usage ? {\n        promptTokens: data.usage.prompt_tokens,\n        completionTokens: data.usage.completion_tokens,\n        totalTokens: data.usage.total_tokens,\n      } : undefined,\n    };\n  }\n  \n  async healthCheck(): Promise<boolean> {\n    try {\n      const result = await this.complete([\n        { role: 'user', content: 'Say \"ok\"' }\n      ], { maxTokens: 10 });\n      return result.content.length > 0;\n    } catch {\n      return false;\n    }\n  }\n}\n\n/**\n * Create a provider for ZAI GLM models\n */\nexport function createZAIProvider(config: ProviderConfig): AIProvider {\n  return new OpenAICompatibleProvider('ZAI', {\n    ...config,\n    baseUrl: config.baseUrl || 'https://api.z.ai/api/coding/paas/v4',\n    model: config.model || 'glm-4.7',\n  });\n}\n\n/**\n * Create a provider for OpenAI models\n */\nexport function createOpenAIProvider(config: ProviderConfig): AIProvider {\n  return new OpenAICompatibleProvider('OpenAI', {\n    ...config,\n    baseUrl: config.baseUrl || 'https://api.openai.com/v1',\n    model: config.model || 'gpt-4o',\n  });\n}\n\n/**\n * Create a provider for DeepSeek models\n */\nexport function createDeepSeekProvider(config: ProviderConfig): AIProvider {\n  return new OpenAICompatibleProvider('DeepSeek', {\n    ...config,\n    baseUrl: config.baseUrl || 'https://api.deepseek.com',\n    model: config.model || 'deepseek-chat',\n  });\n}\n","/**\n * Ollama Provider\n * \n * Provider for local Ollama models.\n */\n\nimport { AIProvider, Message, CompletionOptions, CompletionResult, ProviderConfig } from './types.js';\n\nexport class OllamaProvider implements AIProvider {\n  name = 'Ollama';\n  private config: ProviderConfig;\n  \n  constructor(config: ProviderConfig) {\n    this.config = {\n      ...config,\n      baseUrl: config.baseUrl || 'http://localhost:11434',\n      model: config.model || 'qwen2.5-coder:7b',\n    };\n  }\n  \n  async complete(messages: Message[], options?: CompletionOptions): Promise<CompletionResult> {\n    const endpoint = `${this.config.baseUrl}/api/chat`;\n    \n    const body = {\n      model: this.config.model,\n      messages: messages.map(m => ({\n        role: m.role,\n        content: m.content,\n      })),\n      stream: false,\n      options: {\n        temperature: options?.temperature ?? this.config.options?.temperature ?? 0.2,\n        num_ctx: this.config.options?.num_ctx ?? 8192,\n      },\n    };\n    \n    const response = await fetch(endpoint, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(body),\n    });\n    \n    if (!response.ok) {\n      const errorText = await response.text();\n      throw new Error(`Ollama API error (${response.status}): ${errorText}`);\n    }\n    \n    const data = await response.json() as {\n      message: { content: string };\n      done: boolean;\n      eval_count?: number;\n      prompt_eval_count?: number;\n    };\n    \n    return {\n      content: data.message.content || '',\n      finishReason: data.done ? 'stop' : 'error',\n      usage: data.eval_count ? {\n        promptTokens: data.prompt_eval_count || 0,\n        completionTokens: data.eval_count,\n        totalTokens: (data.prompt_eval_count || 0) + data.eval_count,\n      } : undefined,\n    };\n  }\n  \n  async healthCheck(): Promise<boolean> {\n    try {\n      const response = await fetch(`${this.config.baseUrl}/api/tags`);\n      if (!response.ok) return false;\n      \n      const data = await response.json() as { models: Array<{ name: string }> };\n      const hasModel = data.models.some(m => \n        m.name === this.config.model || m.name.startsWith(this.config.model + ':')\n      );\n      \n      return hasModel;\n    } catch {\n      return false;\n    }\n  }\n  \n  /**\n   * List available models\n   */\n  async listModels(): Promise<string[]> {\n    try {\n      const response = await fetch(`${this.config.baseUrl}/api/tags`);\n      if (!response.ok) return [];\n      \n      const data = await response.json() as { models: Array<{ name: string }> };\n      return data.models.map(m => m.name);\n    } catch {\n      return [];\n    }\n  }\n}\n\nexport function createOllamaProvider(config: ProviderConfig): OllamaProvider {\n  return new OllamaProvider(config);\n}\n","/**\n * Anthropic Provider\n * \n * Provider for Claude models via the Anthropic API.\n */\n\nimport { AIProvider, Message, CompletionOptions, CompletionResult, ProviderConfig } from './types.js';\n\nexport class AnthropicProvider implements AIProvider {\n  name = 'Anthropic';\n  private config: ProviderConfig;\n  \n  constructor(config: ProviderConfig) {\n    if (!config.apiKey) {\n      throw new Error('API key is required for Anthropic provider');\n    }\n    \n    this.config = {\n      ...config,\n      baseUrl: config.baseUrl || 'https://api.anthropic.com',\n      model: config.model || 'claude-sonnet-4-20250514',\n    };\n  }\n  \n  async complete(messages: Message[], options?: CompletionOptions): Promise<CompletionResult> {\n    const endpoint = `${this.config.baseUrl}/v1/messages`;\n    \n    // Extract system message if present\n    const systemMessage = messages.find(m => m.role === 'system');\n    const nonSystemMessages = messages.filter(m => m.role !== 'system');\n    \n    const body = {\n      model: this.config.model,\n      max_tokens: options?.maxTokens ?? this.config.options?.max_tokens ?? 4096,\n      ...(systemMessage && { system: systemMessage.content }),\n      messages: nonSystemMessages.map(m => ({\n        role: m.role,\n        content: m.content,\n      })),\n      ...(options?.temperature !== undefined && { temperature: options.temperature }),\n      ...(options?.stopSequences && { stop_sequences: options.stopSequences }),\n    };\n    \n    const response = await fetch(endpoint, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'x-api-key': this.config.apiKey!,\n        'anthropic-version': '2023-06-01',\n      },\n      body: JSON.stringify(body),\n    });\n    \n    if (!response.ok) {\n      const errorText = await response.text();\n      throw new Error(`Anthropic API error (${response.status}): ${errorText}`);\n    }\n    \n    const data = await response.json() as {\n      content: Array<{ type: string; text: string }>;\n      stop_reason: string;\n      usage: {\n        input_tokens: number;\n        output_tokens: number;\n      };\n    };\n    \n    const textContent = data.content\n      .filter(c => c.type === 'text')\n      .map(c => c.text)\n      .join('');\n    \n    return {\n      content: textContent,\n      finishReason: data.stop_reason === 'end_turn' ? 'stop' : \n                    data.stop_reason === 'max_tokens' ? 'length' : 'error',\n      usage: {\n        promptTokens: data.usage.input_tokens,\n        completionTokens: data.usage.output_tokens,\n        totalTokens: data.usage.input_tokens + data.usage.output_tokens,\n      },\n    };\n  }\n  \n  async healthCheck(): Promise<boolean> {\n    try {\n      const result = await this.complete([\n        { role: 'user', content: 'Say \"ok\"' }\n      ], { maxTokens: 10 });\n      return result.content.length > 0;\n    } catch {\n      return false;\n    }\n  }\n}\n\nexport function createAnthropicProvider(config: ProviderConfig): AIProvider {\n  return new AnthropicProvider(config);\n}\n","/**\n * Argus AI Providers\n * \n * Factory for creating AI providers based on configuration.\n */\n\nimport { ArgusConfig, ProviderType, ProviderConfig } from '../core/config.js';\nimport { AIProvider } from './types.js';\nimport { createZAIProvider, createOpenAIProvider, createDeepSeekProvider } from './openai-compatible.js';\nimport { createOllamaProvider } from './ollama.js';\nimport { createAnthropicProvider } from './anthropic.js';\n\nexport type { AIProvider, Message, CompletionOptions, CompletionResult, ProviderConfig } from './types.js';\nexport { createZAIProvider, createOpenAIProvider, createDeepSeekProvider } from './openai-compatible.js';\nexport { createOllamaProvider, OllamaProvider } from './ollama.js';\nexport { createAnthropicProvider } from './anthropic.js';\n\n/**\n * Create an AI provider from Argus configuration\n */\nexport function createProvider(config: ArgusConfig): AIProvider {\n  const providerType = config.provider;\n  const providerConfig = config.providers[providerType];\n  \n  if (!providerConfig) {\n    throw new Error(`No configuration found for provider: ${providerType}`);\n  }\n  \n  return createProviderByType(providerType, providerConfig);\n}\n\n/**\n * Create an AI provider by type and config\n */\nexport function createProviderByType(type: ProviderType, config: ProviderConfig): AIProvider {\n  switch (type) {\n    case 'zai':\n      return createZAIProvider(config);\n    case 'openai':\n      return createOpenAIProvider(config);\n    case 'deepseek':\n      return createDeepSeekProvider(config);\n    case 'ollama':\n      return createOllamaProvider(config);\n    case 'anthropic':\n      return createAnthropicProvider(config);\n    default:\n      throw new Error(`Unknown provider type: ${type}`);\n  }\n}\n\n/**\n * Get a human-readable name for a provider\n */\nexport function getProviderDisplayName(type: ProviderType): string {\n  switch (type) {\n    case 'zai':\n      return 'ZAI (GLM)';\n    case 'openai':\n      return 'OpenAI';\n    case 'deepseek':\n      return 'DeepSeek';\n    case 'ollama':\n      return 'Ollama (Local)';\n    case 'anthropic':\n      return 'Anthropic (Claude)';\n    default:\n      return type;\n  }\n}\n\n/**\n * List all available provider types\n */\nexport function listProviderTypes(): ProviderType[] {\n  return ['zai', 'anthropic', 'openai', 'deepseek', 'ollama'];\n}\n","import express, { Request, Response } from 'express';\nimport { SnapshotCache } from './cache.js';\nimport { ProjectWatcher } from './watcher.js';\n\nconst PORT = process.env.ARGUS_WORKER_PORT || 37778;\n\nexport function startWorker() {\n  const app = express();\n  const cache = new SnapshotCache({ maxSize: 5 });\n  const watchers = new Map<string, ProjectWatcher>();\n\n  app.use(express.json());\n\n  // Health check\n  app.get('/health', (_req: Request, res: Response) => {\n    res.json({\n      status: 'ok',\n      version: '2.0.0',\n      cached: cache.size,\n      watching: watchers.size,\n    });\n  });\n\n  // Load snapshot into memory\n  app.post('/snapshot/load', async (req: Request, res: Response) => {\n    const { path } = req.body;\n    try {\n      const snapshot = await cache.load(path);\n      res.json({\n        success: true,\n        fileCount: snapshot.fileCount,\n        cached: true,\n      });\n    } catch (error) {\n      res.status(400).json({ error: (error as Error).message });\n    }\n  });\n\n  // Search using cached snapshot\n  app.post('/search', (req: Request, res: Response) => {\n    const { path, pattern, options } = req.body;\n    try {\n      const results = cache.search(path, pattern, options || {});\n      res.json(results);\n    } catch (error) {\n      res.status(400).json({ error: (error as Error).message });\n    }\n  });\n\n  // Get context from cached snapshot\n  app.post('/context', (req: Request, res: Response) => {\n    const { path, file, line, before, after } = req.body;\n    try {\n      const context = cache.getContext(path, file, line, before || 10, after || 10);\n      res.json(context);\n    } catch (error) {\n      res.status(400).json({ error: (error as Error).message });\n    }\n  });\n\n  // Notify of file changes\n  app.post('/notify-change', (req: Request, res: Response) => {\n    const { projectPath } = req.body;\n    const snapshotPath = `${projectPath}/.argus/snapshot.txt`;\n    cache.invalidate(snapshotPath);\n    res.json({ invalidated: true });\n  });\n\n  // Start watching a project\n  app.post('/watch', (req: Request, res: Response) => {\n    const { projectPath, snapshotPath } = req.body;\n\n    if (!watchers.has(projectPath)) {\n      const watcher = new ProjectWatcher(projectPath, snapshotPath, () => {\n        cache.invalidate(snapshotPath);\n      });\n      watchers.set(projectPath, watcher);\n    }\n\n    res.json({ watching: true, path: projectPath });\n  });\n\n  // Stop watching\n  app.delete('/watch', (req: Request, res: Response) => {\n    const { projectPath } = req.body;\n    const watcher = watchers.get(projectPath);\n    if (watcher) {\n      watcher.close();\n      watchers.delete(projectPath);\n    }\n    res.json({ watching: false });\n  });\n\n  const server = app.listen(PORT, () => {\n    console.log(`Argus worker listening on port ${PORT}`);\n  });\n\n  return { app, server, cache, watchers };\n}\n","import { readFileSync, statSync } from 'fs';\n\ninterface CachedSnapshot {\n  path: string;\n  content: string;\n  lines: string[];\n  fileIndex: Map<string, { start: number; end: number }>;\n  loadedAt: Date;\n  fileCount: number;\n  mtime: number;\n}\n\nexport class SnapshotCache {\n  private cache: Map<string, CachedSnapshot> = new Map();\n  private accessOrder: string[] = [];\n  private maxSize: number;\n\n  constructor(options: { maxSize: number }) {\n    this.maxSize = options.maxSize;\n  }\n\n  get size(): number {\n    return this.cache.size;\n  }\n\n  async load(path: string): Promise<CachedSnapshot> {\n    const stats = statSync(path);\n    const cached = this.cache.get(path);\n\n    // Return cached if still valid\n    if (cached && cached.mtime === stats.mtimeMs) {\n      this.touchAccess(path);\n      return cached;\n    }\n\n    // Load and parse\n    const content = readFileSync(path, 'utf-8');\n    const lines = content.split('\\n');\n    const fileIndex = this.buildFileIndex(lines);\n    const fileCount = (content.match(/^FILE: /gm) || []).length;\n\n    const snapshot: CachedSnapshot = {\n      path,\n      content,\n      lines,\n      fileIndex,\n      loadedAt: new Date(),\n      fileCount,\n      mtime: stats.mtimeMs,\n    };\n\n    // Evict if at capacity\n    if (this.cache.size >= this.maxSize) {\n      const oldest = this.accessOrder.shift()!;\n      this.cache.delete(oldest);\n    }\n\n    this.cache.set(path, snapshot);\n    this.accessOrder.push(path);\n\n    return snapshot;\n  }\n\n  invalidate(path: string): void {\n    this.cache.delete(path);\n    this.accessOrder = this.accessOrder.filter(p => p !== path);\n  }\n\n  search(\n    path: string,\n    pattern: string,\n    options: { caseInsensitive?: boolean; maxResults?: number; offset?: number } = {}\n  ): { matches: Array<{ lineNum: number; line: string; match: string }>; count: number } {\n    const snapshot = this.cache.get(path);\n    if (!snapshot) {\n      throw new Error('Snapshot not loaded. Call /snapshot/load first.');\n    }\n\n    const flags = options.caseInsensitive ? 'gi' : 'g';\n    const regex = new RegExp(pattern, flags);\n    const matches: Array<{ lineNum: number; line: string; match: string }> = [];\n    const maxResults = options.maxResults || 50;\n    const offset = options.offset || 0;\n    let found = 0;\n\n    for (let i = 0; i < snapshot.lines.length; i++) {\n      const line = snapshot.lines[i];\n      const match = regex.exec(line);\n      regex.lastIndex = 0; // Reset for global regex\n\n      if (match) {\n        if (found >= offset && matches.length < maxResults) {\n          matches.push({\n            lineNum: i + 1,\n            line: line.trim(),\n            match: match[0],\n          });\n        }\n        found++;\n        if (matches.length >= maxResults) break;\n      }\n    }\n\n    return { matches, count: matches.length };\n  }\n\n  getContext(\n    path: string,\n    file: string,\n    line: number,\n    before: number = 10,\n    after: number = 10\n  ): { content: string; range: { start: number; end: number } } {\n    const snapshot = this.cache.get(path);\n    if (!snapshot) throw new Error('Snapshot not loaded');\n\n    const normalizedFile = file.replace(/^\\.\\//, '');\n    const fileRange = snapshot.fileIndex.get(normalizedFile);\n\n    if (!fileRange) throw new Error(`File not found: ${file}`);\n\n    const fileLines = snapshot.lines.slice(fileRange.start, fileRange.end);\n    const startLine = Math.max(0, line - before - 1);\n    const endLine = Math.min(fileLines.length, line + after);\n\n    const contextLines = fileLines.slice(startLine, endLine).map((l, idx) => {\n      const lineNum = startLine + idx + 1;\n      const marker = lineNum === line ? '>>>' : '   ';\n      return `${marker} ${lineNum.toString().padStart(4)}: ${l}`;\n    });\n\n    return {\n      content: contextLines.join('\\n'),\n      range: { start: startLine + 1, end: endLine },\n    };\n  }\n\n  private buildFileIndex(lines: string[]): Map<string, { start: number; end: number }> {\n    const index = new Map<string, { start: number; end: number }>();\n    let currentFile: string | null = null;\n    let currentStart = 0;\n\n    for (let i = 0; i < lines.length; i++) {\n      const line = lines[i];\n\n      if (line.startsWith('FILE: ./')) {\n        if (currentFile) {\n          index.set(currentFile, { start: currentStart, end: i - 1 });\n        }\n        currentFile = line.slice(8);\n        currentStart = i + 2;\n      }\n\n      if (line.startsWith('METADATA:') && currentFile) {\n        index.set(currentFile, { start: currentStart, end: i - 1 });\n        break;\n      }\n    }\n\n    if (currentFile && !index.has(currentFile)) {\n      index.set(currentFile, { start: currentStart, end: lines.length - 1 });\n    }\n\n    return index;\n  }\n\n  private touchAccess(path: string): void {\n    this.accessOrder = this.accessOrder.filter(p => p !== path);\n    this.accessOrder.push(path);\n  }\n}\n","import { watch, FSWatcher } from 'fs';\n\nexport class ProjectWatcher {\n  private watcher: FSWatcher | null = null;\n  private debounceTimer: NodeJS.Timeout | null = null;\n  private changedFiles: Set<string> = new Set();\n\n  constructor(\n    private projectPath: string,\n    private snapshotPath: string,\n    private onUpdate: (changedFiles: string[]) => void,\n    private debounceMs: number = 1000\n  ) {\n    this.start();\n  }\n\n  private start(): void {\n    try {\n      this.watcher = watch(this.projectPath, { recursive: true }, (eventType, filename) => {\n        if (!filename) return;\n\n        // Skip common noise\n        if (\n          filename.includes('node_modules') ||\n          filename.includes('.git') ||\n          filename.includes('.argus')\n        ) {\n          return;\n        }\n\n        this.changedFiles.add(filename);\n        this.scheduleUpdate();\n      });\n    } catch (error) {\n      console.error(`Failed to watch ${this.projectPath}:`, error);\n    }\n  }\n\n  private scheduleUpdate(): void {\n    if (this.debounceTimer) {\n      clearTimeout(this.debounceTimer);\n    }\n\n    this.debounceTimer = setTimeout(() => {\n      const files = Array.from(this.changedFiles);\n      this.changedFiles.clear();\n      this.onUpdate(files);\n    }, this.debounceMs);\n  }\n\n  close(): void {\n    if (this.watcher) {\n      this.watcher.close();\n      this.watcher = null;\n    }\n    if (this.debounceTimer) {\n      clearTimeout(this.debounceTimer);\n    }\n  }\n}\n"],"mappings":"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","names":["existsSync","readFileSync","writeFileSync","join","content","readFileSync","readFileSync","readFileSync","statSync"]}