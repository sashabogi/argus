================================================================================
CODEBASE SNAPSHOT
Project: /Users/sashabogojevic/development/argus
Generated: 2026-01-17T05:28:15.888Z
Extensions: ts, tsx, js, jsx, rs, py, go, java, rb, php, md
Files: 18
================================================================================


================================================================================
FILE: ./INSTALL.md
================================================================================
# Installation Guide

This guide covers installing Argus on a new machine.

## Prerequisites

- Node.js 18 or later
- npm or pnpm
- API key for your chosen AI provider (unless using Ollama)

## Quick Install (from npm)

Once published:

```bash
npm install -g @hive-dev/argus
argus init
```

## Install from Source (Private Repository)

### 1. Clone the Repository

```bash
git clone git@github.com:hive-dev/argus.git
cd argus
```

### 2. Install Dependencies

```bash
npm install
```

### 3. Build

```bash
npm run build
```

### 4. Link Globally

```bash
npm link
```

This makes `argus` and `argus-mcp` available globally.

### 5. Configure

Run the interactive setup:

```bash
argus init
```

Or manually create `~/.argus/config.json`:

```json
{
  "provider": "zai",
  "providers": {
    "zai": {
      "apiKey": "your-api-key-here",
      "model": "glm-4.7",
      "baseUrl": "https://api.z.ai/api/coding/paas/v4"
    }
  },
  "defaults": {
    "maxTurns": 15,
    "turnTimeoutMs": 60000,
    "snapshotExtensions": ["ts", "tsx", "js", "jsx", "rs", "py", "go", "java", "md"],
    "excludePatterns": ["node_modules", ".git", "target", "dist", "build"]
  }
}
```

### 6. Verify Installation

```bash
# Check version
argus --version

# Test configuration
argus config
```

## Claude Code Integration

### Install MCP Server

```bash
argus mcp install
```

This:
1. Creates a wrapper script at `~/.argus/argus-mcp-wrapper`
2. Registers Argus with Claude Code

### Manual Installation

If automatic installation fails:

```bash
# Create wrapper manually
cat > ~/.argus/argus-mcp-wrapper << 'EOF'
#!/bin/bash
export PATH="/opt/homebrew/bin:/usr/local/bin:$HOME/.npm-global/bin:$PATH"
export ARGUS_PROVIDER="zai"
export ARGUS_MODEL="glm-4.7"
export ARGUS_API_KEY="your-api-key"
export ARGUS_BASE_URL="https://api.z.ai/api/coding/paas/v4"
exec argus-mcp "$@"
EOF

chmod +x ~/.argus/argus-mcp-wrapper

# Add to Claude Code
claude mcp add argus -s user -- ~/.argus/argus-mcp-wrapper
```

### Verify MCP

```bash
claude mcp list
# Should show: argus: ... - ‚úì Connected
```

## Provider Setup

### ZAI (GLM-4.7) - Recommended

1. Sign up at [z.ai](https://z.ai/model-api)
2. Subscribe to the GLM Coding Plan ($3/month)
3. Generate an API key
4. Run `argus init` and select ZAI

### Anthropic (Claude)

1. Get an API key from [console.anthropic.com](https://console.anthropic.com)
2. Run `argus init` and select Anthropic

### OpenAI

1. Get an API key from [platform.openai.com](https://platform.openai.com)
2. Run `argus init` and select OpenAI

### DeepSeek

1. Get an API key from [platform.deepseek.com](https://platform.deepseek.com)
2. Run `argus init` and select DeepSeek

### Ollama (Local)

1. Install Ollama: https://ollama.ai
2. Pull a model: `ollama pull qwen2.5-coder:7b`
3. Run `argus init` and select Ollama

## Troubleshooting

### "Provider not configured"

Run `argus init` or manually create `~/.argus/config.json`.

### "Connection failed" in Claude Code

1. Check your API key is valid
2. Verify the MCP wrapper has correct paths: `cat ~/.argus/argus-mcp-wrapper`
3. Restart Claude Code completely (Cmd+Q, reopen)
4. Check MCP status: `claude mcp list`

### "Command not found: argus"

Ensure the npm global bin is in your PATH:

```bash
# Add to ~/.zshrc or ~/.bashrc
export PATH="$HOME/.npm-global/bin:$PATH"

# Or for Homebrew Node
export PATH="/opt/homebrew/bin:$PATH"
```

### Slow Analysis

- Use a larger/faster model (GLM-4.7, Claude, GPT-4o)
- Reduce `maxTurns` if you don't need deep analysis
- Create a snapshot first, then query repeatedly

## Updating

### From npm

```bash
npm update -g @hive-dev/argus
```

### From Source

```bash
cd argus
git pull
npm install
npm run build
```

## Uninstalling

```bash
# Remove from Claude Code
argus mcp uninstall

# Remove global install
npm uninstall -g @hive-dev/argus

# Remove config (optional)
rm -rf ~/.argus
```


================================================================================
FILE: ./README.md
================================================================================
# Argus

**Codebase Intelligence Beyond Context Limits**

Argus is an AI-powered codebase analysis tool that understands your entire project, regardless of size. It provides intelligent answers about code architecture, patterns, and relationships that would be impossible with traditional context-limited approaches.

## Acknowledgments

Argus builds upon and extends the innovative work of [Matryoshka RLM](https://github.com/yogthos/Matryoshka) by [Dmitri Sotnikov (yogthos)](https://github.com/yogthos). 

The Matryoshka project introduced the brilliant concept of **Recursive Language Models (RLM)** - using an LLM to generate symbolic commands (via the [Nucleus DSL](https://github.com/michaelwhitford/nucleus)) that are executed against documents, enabling analysis of files far exceeding context window limits. This approach achieves **93% token savings** compared to traditional methods.

**What Argus adds:**

| Matryoshka | Argus |
|------------|-------|
| Single file analysis | Full codebase analysis |
| CLI-only | CLI + MCP Server for Claude Code |
| Ollama/DeepSeek providers | Multi-provider (ZAI, Anthropic, OpenAI, Ollama, DeepSeek) |
| Manual configuration | Interactive setup wizard |
| Document-focused | Code-aware with snapshot generation |

We encourage you to explore the original [Matryoshka](https://github.com/yogthos/Matryoshka) project and the [RLM research paper](https://arxiv.org/abs/2512.24601) that inspired this approach.

---

## Features

- üîç **Codebase-Wide Analysis** - Analyze entire projects, not just single files
- üß† **AI-Powered Understanding** - Uses LLMs to reason about code structure and patterns
- üîå **MCP Integration** - Works seamlessly with Claude Code
- üåê **Multi-Provider Support** - ZAI GLM-4.7, Claude, GPT-4, DeepSeek, Ollama
- üì∏ **Smart Snapshots** - Intelligent codebase snapshots optimized for analysis
- ‚ö° **Hybrid Search** - Fast grep + AI reasoning for optimal results
- üîß **Easy Setup** - Interactive configuration wizard

## Quick Start

### Installation

```bash
# Install globally
npm install -g @hive-dev/argus

# Interactive setup (configures API keys and preferences)
argus init

# Add to Claude Code (installs MCP + global instructions)
argus mcp install

# Set up any project
argus setup .
```

### How It Works

The `argus mcp install` command does two things:

1. **Installs the MCP server** - Makes Argus tools available in Claude Code
2. **Injects global instructions** - Adds Argus awareness to `~/.claude/CLAUDE.md`

The global instructions apply to **ALL projects** and **ALL sub-agents** (coders, testers, reviewers, debuggers, etc.) regardless of their specific configuration. This means:

- You don't need to modify individual agent files
- New agents you install automatically inherit Argus awareness
- Works with any skill or agent ecosystem

### Per-Project Setup

```bash
# In any project directory
argus setup .
```

This creates `.argus/snapshot.txt` - a compressed representation of your codebase that Argus uses for efficient analysis.

### Basic Usage

```bash
# Analyze a codebase
argus analyze ./my-project "What are the main architectural patterns?"

# Create a snapshot for repeated analysis
argus snapshot ./my-project -o .argus/snapshot.txt

# Query an existing snapshot  
argus query .argus/snapshot.txt "Find all API endpoints"

# Fast grep search (no AI, instant results)
argus search .argus/snapshot.txt "authentication"

# Check if snapshot needs refresh
argus status .
```

### In Claude Code

After running `argus mcp install`, you can use Argus directly:

```
@argus What are the main modules in this codebase?
@argus Find all error handling patterns
@argus How does the authentication flow work?
```

## Configuration

Argus stores configuration in `~/.argus/config.json`. Run `argus init` for interactive setup, or configure manually:

```json
{
  "provider": "zai",
  "providers": {
    "zai": {
      "apiKey": "your-api-key",
      "model": "glm-4.7",
      "endpoint": "https://api.z.ai/api/coding/paas/v4"
    },
    "anthropic": {
      "apiKey": "your-api-key",
      "model": "claude-sonnet-4-20250514"
    },
    "openai": {
      "apiKey": "your-api-key",
      "model": "gpt-4o"
    },
    "deepseek": {
      "apiKey": "your-api-key",
      "model": "deepseek-chat"
    },
    "ollama": {
      "baseUrl": "http://localhost:11434",
      "model": "qwen2.5-coder:7b"
    }
  },
  "defaults": {
    "maxTurns": 15,
    "turnTimeoutMs": 60000,
    "snapshotExtensions": ["ts", "tsx", "js", "jsx", "rs", "py", "go", "java"]
  }
}
```

## Commands

### `argus init`
Interactive setup wizard. Configures your preferred AI provider and API keys.

### `argus analyze <path> <query>`
Analyze a codebase or file with an AI-powered query.

Options:
- `--provider, -p` - Override default provider
- `--max-turns, -t` - Maximum reasoning turns (default: 15)
- `--verbose, -v` - Show detailed execution logs

### `argus snapshot <path> [output]`
Create an optimized snapshot of a codebase for analysis.

Options:
- `--extensions, -e` - File extensions to include (comma-separated)
- `--exclude` - Patterns to exclude
- `--output, -o` - Output file path

### `argus query <snapshot> <query>`
Query an existing snapshot file.

### `argus search <snapshot> <pattern>`
Fast grep search without AI (instant results).

### `argus setup [path]`
One-command project setup. Creates snapshot, updates .gitignore, optionally injects into project CLAUDE.md.

Options:
- `--no-claude-md` - Skip CLAUDE.md injection
- `--no-gitignore` - Skip .gitignore update

### `argus status [path]`
Check if snapshot is up to date. Shows age and files changed since last snapshot.

### `argus mcp install`
Install Argus as an MCP server for Claude Code. Also injects global instructions into `~/.claude/CLAUDE.md`.

Options:
- `--no-claude-md` - Skip global CLAUDE.md injection

### `argus mcp uninstall`
Remove Argus from Claude Code.

### `argus config [key] [value]`
View or modify configuration.

## How It Works

Argus uses a **Recursive Language Model (RLM)** approach:

1. **Snapshot Creation** - Your codebase is compiled into an optimized text snapshot
2. **Query Analysis** - The LLM receives your question and the Nucleus DSL reference
3. **Iterative Exploration** - The LLM generates symbolic commands (grep, filter, map, etc.)
4. **Command Execution** - Commands run against the full snapshot in a sandbox
5. **Reasoning Loop** - Results feed back to the LLM for further analysis
6. **Final Answer** - Once sufficient information is gathered, a comprehensive answer is provided

This allows analysis of codebases **far exceeding** typical context limits (2M+ characters) while using minimal tokens per query.

## Nucleus DSL Reference

Argus uses the [Nucleus DSL](https://github.com/michaelwhitford/nucleus) for document operations:

```lisp
; Search
(grep "pattern")                    ; Find matching lines
(grep "error" "i")                  ; Case-insensitive search

; Transform
(map RESULTS (lambda (x) ...))      ; Transform results
(filter RESULTS (lambda (x) ...))   ; Filter results
(sort RESULTS key)                  ; Sort results

; Aggregate
(count RESULTS)                     ; Count items
(sum RESULTS)                       ; Sum numeric values
(first RESULTS)                     ; Get first item
(take RESULTS n)                    ; Get first n items

; Extract
(match str "pattern" group)         ; Regex extraction
(split str delimiter)               ; Split string

; Final Answer
<<<FINAL>>>your answer here<<<END>>>
```

## Supported Providers

| Provider | Models | Best For |
|----------|--------|----------|
| **ZAI** | GLM-4.7, GLM-4.6 | Best value, excellent coding |
| **Anthropic** | Claude Sonnet/Opus | Highest quality reasoning |
| **OpenAI** | GPT-4o, GPT-4 | General purpose |
| **DeepSeek** | DeepSeek Chat/Coder | Budget-friendly |
| **Ollama** | Qwen, CodeLlama, etc. | Free, local, private |

## Requirements

- Node.js 18+
- npm or pnpm
- API key for your chosen provider (or Ollama for free local usage)

## FAQ & Documentation

- **[FAQ](./docs/FAQ.md)** - Common questions about costs, workflow, and troubleshooting
- **[CLAUDE.md Integration](./docs/CLAUDE_MD_INTEGRATION.md)** - How to add Argus to your project's CLAUDE.md

### Quick Answers

**"Do I need to pay for another API?"**  
No! Use Ollama (free, local) or `argus search` (no AI at all).

**"I'm starting a fresh project - how does Argus help?"**  
Argus works from Day 0. Snapshot your PRD/TDD, then refresh as you build. See [FAQ](./docs/FAQ.md#im-starting-a-brand-new-project---theres-nothing-to-scan-yet).

**"How do I keep the snapshot updated?"**  
Run `argus status .` to check, then `argus snapshot .` to refresh. See [FAQ](./docs/FAQ.md#how-do-i-keep-the-snapshot-up-to-date).

## License

MIT License - See [LICENSE](./LICENSE)

## Contributing

Contributions are welcome! Please read our contributing guidelines before submitting PRs.

## Related Projects

- [Matryoshka RLM](https://github.com/yogthos/Matryoshka) - The original RLM implementation that inspired Argus
- [Nucleus DSL](https://github.com/michaelwhitford/nucleus) - The symbolic language used for document operations
- [RLM Paper](https://arxiv.org/abs/2512.24601) - Academic research on Recursive Language Models


================================================================================
FILE: ./docs/CLAUDE_MD_INTEGRATION.md
================================================================================
# Argus Integration with Claude Code

Argus integrates with Claude Code at **two levels** to ensure all agents (main session AND sub-agents) use efficient codebase exploration.

## How Integration Works

### Level 1: Global (All Projects, All Agents)

When you run `argus mcp install`, it:

1. Installs the MCP server for Claude Code
2. Injects instructions into `~/.claude/CLAUDE.md` (global)

The global instructions apply to **every project** and **every sub-agent** regardless of type (coder, tester, reviewer, debugger, or any custom agent). This means:

- New agents you install automatically inherit Argus awareness
- Works with any skill or agent ecosystem
- No need to modify individual agent files

### Level 2: Per-Project (Snapshot)

When you run `argus setup .` in a project, it:

1. Creates `.argus/snapshot.txt` (compressed codebase)
2. Adds `.argus/` to `.gitignore`
3. Optionally injects project-specific instructions into the project's `CLAUDE.md`

## Quick Start

```bash
# One-time global setup
argus init           # Configure API key
argus mcp install    # MCP server + global CLAUDE.md injection

# Per-project setup
cd your-project
argus setup .        # Creates snapshot + updates .gitignore
```

That's it! Claude Code and all sub-agents will now:
1. Check for `.argus/snapshot.txt` before multi-file exploration
2. Use `search_codebase` (FREE) to find relevant files
3. Only read the specific files needed

## What Gets Injected

### Global `~/.claude/CLAUDE.md`

```markdown
## Codebase Intelligence (Argus) ‚Äî ALL AGENTS

> This applies to the main session AND all sub-agents/tasks regardless of type.

### The Rule: Argus Before Multi-File Exploration

Before reading more than 3 files to understand a codebase, use Argus MCP tools:

1. Check for snapshot: Look for `.argus/snapshot.txt` in the project
2. Search first (FREE): `search_codebase(".argus/snapshot.txt", "pattern")`
3. Understand if needed (~500 tokens): `analyze_codebase(".argus/snapshot.txt", "How does X work?")`
4. Then read specific files: Only the files Argus identified as relevant
```

## Available MCP Tools

| Tool | Cost | Use For |
|------|------|---------|
| `search_codebase` | **FREE** | Finding files, patterns, definitions |
| `analyze_codebase` | ~500 tokens | Architecture questions, understanding flows |
| `create_snapshot` | ~100 tokens | Refreshing the snapshot after major changes |

## Keeping Snapshots Updated

```bash
# Check if snapshot is stale
argus status .

# Refresh after major changes
argus snapshot . -o .argus/snapshot.txt

# Or use the setup command again
argus setup .
```

## Manual Integration (Optional)

If you prefer manual control, you can skip the automatic injection:

```bash
# Install MCP only, skip global CLAUDE.md
argus mcp install --no-claude-md

# Setup project, skip project CLAUDE.md  
argus setup . --no-claude-md
```

Then manually add the Argus section to your CLAUDE.md files as needed.

## Troubleshooting

### Sub-agents not using Argus?

1. Verify global injection: `grep "Argus" ~/.claude/CLAUDE.md`
2. Verify snapshot exists: `ls -la .argus/snapshot.txt`
3. Restart Claude Code to pick up CLAUDE.md changes

### Snapshot too large?

Customize excluded patterns in `~/.argus/config.json`:

```json
{
  "defaults": {
    "excludePatterns": ["node_modules", ".git", "dist", "build", ".next"]
  }
}
```

### Want to use a different snapshot location?

The tools accept any path. You can store snapshots anywhere:

```
search_codebase("/path/to/custom-snapshot.txt", "pattern")
```


================================================================================
FILE: ./docs/FAQ.md
================================================================================
# Argus - Frequently Asked Questions

## Token Costs & Pricing

### "Do I need to pay for another API subscription?"

**No!** You have several free options:

| Provider | Cost | Notes |
|----------|------|-------|
| **Ollama (local)** | **$0** | Runs on your machine, no API needed |
| `argus search` | **$0** | Grep-based search, no AI at all |
| DeepSeek | ~$0.001/query | Extremely cheap if you want cloud |
| ZAI GLM-4.7 | ~$0.002/query | Best quality-to-cost ratio |

**Recommended for most users:** Install Ollama (free) and use `qwen2.5-coder:7b`

```bash
# Install Ollama (macOS)
brew install ollama

# Pull a code-optimized model
ollama pull qwen2.5-coder:7b

# Configure Argus
argus init  # Select Ollama
```

### "Isn't running Argus just burning tokens anyway?"

**Math comparison:**

| Action | Tokens Used |
|--------|-------------|
| Claude re-scans 200 files | 100,000 - 500,000 |
| One Argus query | 500 - 2,000 |
| `argus search` (grep) | **0** |

Even with API costs, Argus is **50-250x cheaper** than re-scanning. And with Ollama, it's completely free.

### "I only have Claude Pro/Max subscription, no API key"

Three options:

1. **Use Ollama** - Free, local, no API needed
2. **Use `argus search` only** - Pure grep, zero AI, still very useful
3. **Pre-generate docs once** - Pay for one API call, use the output forever:
   ```bash
   argus analyze snapshot.txt "Full architecture" > ARCHITECTURE.md
   ```

---

## Project Lifecycle

### "I'm starting a brand new project - there's nothing to scan yet"

**Argus works from Day 0.** Here's the progressive workflow:

#### Phase 0: Just PRD/TDD (No Code Yet)

```bash
# Your project only has docs
my-project/
‚îú‚îÄ‚îÄ PRD.md
‚îú‚îÄ‚îÄ TDD.md
‚îî‚îÄ‚îÄ CLAUDE.md

# Set up Argus (creates snapshot of what exists)
argus setup .

# Ask questions about the PLANNED architecture
argus analyze .argus/snapshot.txt "Based on the PRD, what modules will we need?"
```

#### Phase 1: After Initial Scaffold

```bash
# Project now has structure
my-project/
‚îú‚îÄ‚îÄ PRD.md
‚îú‚îÄ‚îÄ TDD.md
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ index.ts
‚îÇ   ‚îú‚îÄ‚îÄ auth/
‚îÇ   ‚îî‚îÄ‚îÄ api/
‚îî‚îÄ‚îÄ package.json

# Refresh snapshot
argus setup .   # or: argus snapshot . -o .argus/snapshot.txt

# Generate first ARCHITECTURE.md
argus analyze .argus/snapshot.txt "Document current architecture" > ARCHITECTURE.md
```

#### Phase 2: After Each Major Feature

```bash
# Just finished implementing auth - refresh
argus snapshot . -o .argus/snapshot.txt

# Check status anytime
argus status .
```

### "How do I keep the snapshot up to date?"

**Check if it's stale:**
```bash
argus status .
```

**Option 1: Manual (Recommended)**
```bash
# After completing a feature
argus snapshot . -o .argus/snapshot.txt
```

**Option 2: Git Hook (Automatic)**
```bash
# .git/hooks/post-commit
#!/bin/bash
argus snapshot . -o .argus/snapshot.txt
```

### "What if Claude built something but I forgot to update the snapshot?"

This is why we recommend **snapshots after each major feature**, not continuous updates. But if you forgot:

```bash
# Quick refresh
argus snapshot . -o .argus/snapshot.txt

# Ask what's new since last time
argus analyze .argus/snapshot.txt "What modules exist? List all with brief descriptions"
```

---

## Claude Code Integration

### "How do I use this with Claude Code specifically?"

**One-time setup:**
```bash
argus init           # Configure your API provider
argus mcp install    # Installs MCP + global CLAUDE.md injection
```

**Per-project setup:**
```bash
cd your-project
argus setup .        # Creates snapshot + updates .gitignore
```

That's it! The `mcp install` command automatically injects Argus awareness into your global `~/.claude/CLAUDE.md`, which applies to ALL projects and ALL sub-agents.

### "Do I need to modify my agent files?"

**No!** The global injection means:
- ALL sub-agents (coders, testers, reviewers, debuggers, etc.) inherit Argus awareness
- New agents you install automatically know about Argus
- Works with any skill or agent ecosystem (50,000+ and counting)

You don't need to touch individual agent files like `coder.md` or `reviewer.md`.

### "Can Claude Code run Argus automatically?"

Yes! After `argus mcp install`, Claude Code has these tools:
- `analyze_codebase` - AI-powered questions (~500 tokens)
- `search_codebase` - Fast grep (**FREE**, no AI)
- `create_snapshot` - Refresh the snapshot

The global CLAUDE.md instructions tell Claude to use `search_codebase` before reading 3+ files, saving massive amounts of tokens.

### "What if sub-agents are still reading many files?"

1. Verify the global injection exists:
   ```bash
   grep "Codebase Intelligence (Argus)" ~/.claude/CLAUDE.md
   ```

2. Verify the snapshot exists:
   ```bash
   ls -la .argus/snapshot.txt
   ```

3. Restart Claude Code to pick up CLAUDE.md changes

---

## Troubleshooting

### "Argus query hit max turns without answering"

Try:
1. **Simpler question**: "How many files?" instead of "Explain the entire architecture"
2. **Use search first**: `argus search snapshot.txt "auth"` then ask about specific files
3. **Increase turns**: `argus analyze snapshot.txt "question" --max-turns 20`

### "Snapshot is too large"

Exclude unnecessary files:
```bash
# Check what's included
head -100 .argus/snapshot.txt

# Customize exclusions in argus config
argus config exclude "*.test.ts,*.spec.ts,*.min.js"
```

### "Ollama is slow"

Try a smaller model:
```bash
ollama pull qwen2.5-coder:3b  # Faster, less accurate
ollama pull codellama:7b      # Good balance
```

Or use cloud provider for complex queries, Ollama for simple ones.


================================================================================
FILE: ./src/cli.ts
================================================================================
/**
 * Argus CLI
 * 
 * Command-line interface for Argus codebase intelligence.
 */

import { Command } from 'commander';
import { existsSync, readFileSync, writeFileSync, statSync, unlinkSync, readdirSync, mkdirSync } from 'fs';
import { homedir } from 'os';
import { join, resolve, basename } from 'path';
import { execSync } from 'child_process';

import {
  loadConfig,
  saveConfig,
  getConfigPath,
  ensureConfigDir,
  validateConfig,
  PROVIDER_DEFAULTS,
  ArgusConfig,
  ProviderType,
} from './core/config.js';
import { createSnapshot, getSnapshotStats } from './core/snapshot.js';
import { analyze, searchDocument } from './core/engine.js';
import { createProvider, listProviderTypes, getProviderDisplayName } from './providers/index.js';

const program = new Command();

program
  .name('argus')
  .description('Codebase Intelligence Beyond Context Limits')
  .version('1.0.0');

// ============================================================================
// argus init
// ============================================================================
program
  .command('init')
  .description('Interactive setup wizard')
  .action(async () => {
    console.log('\nüîÆ Argus Setup Wizard\n');
    console.log('This will configure your AI provider and create ~/.argus/config.json\n');
    
    // Dynamic import for inquirer (ESM)
    const inquirer = await import('inquirer');
    
    const providers = listProviderTypes();
    const providerChoices = providers.map(p => ({
      name: `${getProviderDisplayName(p)} - ${getProviderDescription(p)}`,
      value: p,
    }));
    
    const answers = await inquirer.default.prompt([
      {
        type: 'list',
        name: 'provider',
        message: 'Select your AI provider:',
        choices: providerChoices,
      },
      {
        type: 'input',
        name: 'apiKey',
        message: 'Enter your API key:',
        when: (ans: { provider: ProviderType }) => ans.provider !== 'ollama',
        validate: (input: string) => input.length > 0 || 'API key is required',
      },
      {
        type: 'input',
        name: 'model',
        message: 'Enter model name (leave empty for default):',
        default: (ans: { provider: ProviderType }) => PROVIDER_DEFAULTS[ans.provider]?.model || '',
      },
      {
        type: 'input',
        name: 'baseUrl',
        message: 'Enter custom base URL (leave empty for default):',
        when: (ans: { provider: ProviderType }) => ans.provider === 'ollama',
        default: 'http://localhost:11434',
      },
    ]);
    
    // Build config
    const config: ArgusConfig = {
      provider: answers.provider,
      providers: {
        [answers.provider]: {
          ...(answers.apiKey && { apiKey: answers.apiKey }),
          ...(answers.baseUrl && { baseUrl: answers.baseUrl }),
          model: answers.model || PROVIDER_DEFAULTS[answers.provider as ProviderType]?.model || '',
          ...PROVIDER_DEFAULTS[answers.provider as ProviderType],
        },
      },
      defaults: {
        maxTurns: 15,
        turnTimeoutMs: 60000,
        snapshotExtensions: ['ts', 'tsx', 'js', 'jsx', 'rs', 'py', 'go', 'java', 'rb', 'php', 'md'],
        excludePatterns: ['node_modules', '.git', 'target', 'dist', 'build', '.next'],
      },
    };
    
    saveConfig(config);
    console.log(`\n‚úÖ Configuration saved to ${getConfigPath()}`);
    
    // Test connection
    console.log('\nüîç Testing connection...');
    try {
      const provider = createProvider(config);
      const healthy = await provider.healthCheck();
      if (healthy) {
        console.log('‚úÖ Connection successful!\n');
      } else {
        console.log('‚ö†Ô∏è  Connection test failed. Please check your configuration.\n');
      }
    } catch (error) {
      console.log(`‚ö†Ô∏è  Connection test failed: ${error instanceof Error ? error.message : error}\n`);
    }
    
    console.log('Next steps:');
    console.log('  argus snapshot ./my-project -o snapshot.txt');
    console.log('  argus analyze snapshot.txt "What are the main modules?"');
    console.log('  argus mcp install  # Add to Claude Code');
  });

// ============================================================================
// argus analyze
// ============================================================================
program
  .command('analyze <path> <query>')
  .description('Analyze a codebase or snapshot with AI')
  .option('-p, --provider <provider>', 'Override default provider')
  .option('-t, --max-turns <n>', 'Maximum reasoning turns', '15')
  .option('-v, --verbose', 'Show detailed execution logs')
  .action(async (path: string, query: string, opts) => {
    const config = loadConfig();
    
    if (opts.provider) {
      config.provider = opts.provider as ProviderType;
    }
    
    const errors = validateConfig(config);
    if (errors.length > 0) {
      console.error('Configuration errors:');
      errors.forEach(e => console.error(`  - ${e}`));
      console.error('\nRun `argus init` to configure.');
      process.exit(1);
    }
    
    const resolvedPath = resolve(path);
    
    if (!existsSync(resolvedPath)) {
      console.error(`File not found: ${resolvedPath}`);
      process.exit(1);
    }
    
    // Check if it's a directory - if so, create a temporary snapshot
    let snapshotPath = resolvedPath;
    let tempSnapshot = false;
    
    const stats = statSync(resolvedPath);
    if (stats.isDirectory()) {
      console.log('üì∏ Creating snapshot of codebase...');
      snapshotPath = join(homedir(), '.argus', `temp-${Date.now()}.txt`);
      ensureConfigDir();
      
      const result = createSnapshot(resolvedPath, snapshotPath, {
        extensions: config.defaults.snapshotExtensions,
        excludePatterns: config.defaults.excludePatterns,
      });
      
      console.log(`   ${result.fileCount} files, ${formatSize(result.totalSize)}`);
      tempSnapshot = true;
    }
    
    console.log(`\nüîç Analyzing with ${getProviderDisplayName(config.provider)}...`);
    console.log(`   Query: ${query}\n`);
    
    try {
      const provider = createProvider(config);
      const result = await analyze(provider, snapshotPath, query, {
        maxTurns: parseInt(opts.maxTurns),
        verbose: opts.verbose,
        onProgress: (turn, cmd) => {
          if (!opts.verbose) {
            process.stdout.write(`\r   Turn ${turn}: ${cmd.slice(0, 50)}...`);
          }
        },
      });
      
      if (!opts.verbose) {
        console.log('\n');
      }
      
      if (result.success) {
        console.log('üìã Answer:\n');
        console.log(result.answer);
        console.log(`\n(${result.turns} turns, ${result.commands.length} commands)`);
      } else {
        console.log('‚ö†Ô∏è  Analysis incomplete:');
        console.log(result.answer);
        if (result.error) {
          console.log(`Error: ${result.error}`);
        }
      }
    } finally {
      // Clean up temp snapshot
      if (tempSnapshot && existsSync(snapshotPath)) {
        unlinkSync(snapshotPath);
      }
    }
  });

// ============================================================================
// argus snapshot
// ============================================================================
program
  .command('snapshot <path>')
  .description('Create a codebase snapshot for analysis')
  .option('-o, --output <file>', 'Output file path')
  .option('-e, --extensions <exts>', 'File extensions to include (comma-separated)')
  .option('--exclude <patterns>', 'Patterns to exclude (comma-separated)')
  .action((path: string, opts) => {
    const config = loadConfig();
    const resolvedPath = resolve(path);
    
    if (!existsSync(resolvedPath)) {
      console.error(`Path not found: ${resolvedPath}`);
      process.exit(1);
    }
    
    const outputPath = opts.output || `${basename(resolvedPath)}-snapshot.txt`;
    
    console.log('üì∏ Creating codebase snapshot...');
    console.log(`   Source: ${resolvedPath}`);
    console.log(`   Output: ${outputPath}`);
    
    const extensions = opts.extensions 
      ? opts.extensions.split(',').map((e: string) => e.trim())
      : config.defaults.snapshotExtensions;
    
    const excludePatterns = opts.exclude
      ? opts.exclude.split(',').map((p: string) => p.trim())
      : config.defaults.excludePatterns;
    
    const result = createSnapshot(resolvedPath, outputPath, {
      extensions,
      excludePatterns,
    });
    
    console.log(`\n‚úÖ Snapshot created!`);
    console.log(`   Files: ${result.fileCount}`);
    console.log(`   Lines: ${result.totalLines.toLocaleString()}`);
    console.log(`   Size: ${formatSize(result.totalSize)}`);
    console.log(`\nAnalyze with:`);
    console.log(`   argus analyze ${outputPath} "Your query here"`);
  });

// ============================================================================
// argus query
// ============================================================================
program
  .command('query <snapshot> <query>')
  .description('Query an existing snapshot')
  .option('-v, --verbose', 'Show detailed execution logs')
  .action(async (snapshot: string, query: string, opts) => {
    // Alias for analyze with a snapshot file
    await program.commands.find(c => c.name() === 'analyze')?.parseAsync([
      snapshot, query,
      ...(opts.verbose ? ['-v'] : []),
    ], { from: 'user' });
  });

// ============================================================================
// argus search
// ============================================================================
program
  .command('search <snapshot> <pattern>')
  .description('Fast grep search (no AI)')
  .option('-i, --ignore-case', 'Case-insensitive search')
  .option('-n, --max-results <n>', 'Maximum results', '50')
  .action((snapshot: string, pattern: string, opts) => {
    const resolvedPath = resolve(snapshot);
    
    if (!existsSync(resolvedPath)) {
      console.error(`File not found: ${resolvedPath}`);
      process.exit(1);
    }
    
    console.log(`üîç Searching for: ${pattern}\n`);
    
    const matches = searchDocument(resolvedPath, pattern, {
      caseInsensitive: opts.ignoreCase,
      maxResults: parseInt(opts.maxResults),
    });
    
    if (matches.length === 0) {
      console.log('No matches found.');
      return;
    }
    
    console.log(`Found ${matches.length} matches:\n`);
    
    for (const match of matches) {
      console.log(`${match.lineNum}: ${match.line.trim()}`);
    }
  });

// ============================================================================
// argus status - Check if snapshot is up to date
// ============================================================================
program
  .command('status [path]')
  .description('Check if snapshot is up to date')
  .option('-s, --snapshot <file>', 'Snapshot file to check', '.argus/snapshot.txt')
  .action((path: string | undefined, opts) => {
    const projectPath = path ? resolve(path) : process.cwd();
    const snapshotPath = resolve(projectPath, opts.snapshot);
    
    console.log('üìä Argus Status\n');
    
    // Check if snapshot exists
    if (!existsSync(snapshotPath)) {
      console.log('‚ùå No snapshot found at:', snapshotPath);
      console.log('\nCreate one with:');
      console.log(`   argus snapshot ${projectPath} -o ${snapshotPath}`);
      return;
    }
    
    // Get snapshot stats
    const snapshotStats = statSync(snapshotPath);
    const snapshotAge = Date.now() - snapshotStats.mtimeMs;
    const ageHours = Math.floor(snapshotAge / (1000 * 60 * 60));
    const ageDays = Math.floor(ageHours / 24);
    
    console.log('Snapshot:', snapshotPath);
    console.log('Size:', formatSize(snapshotStats.size));
    
    if (ageDays > 0) {
      console.log('Age:', `${ageDays} day${ageDays > 1 ? 's' : ''} ago`);
    } else if (ageHours > 0) {
      console.log('Age:', `${ageHours} hour${ageHours > 1 ? 's' : ''} ago`);
    } else {
      console.log('Age:', 'Less than an hour ago');
    }
    
    // Count files modified since snapshot
    const config = loadConfig();
    let modifiedCount = 0;
    let newCount = 0;
    
    function checkDir(dir: string) {
      try {
        const entries = readdirSync(dir, { withFileTypes: true });
        for (const entry of entries) {
          const fullPath = join(dir, entry.name);
          
          // Skip excluded patterns
          if (config.defaults.excludePatterns.some(p => fullPath.includes(p))) {
            continue;
          }
          
          if (entry.isDirectory()) {
            checkDir(fullPath);
          } else if (entry.isFile()) {
            const ext = entry.name.split('.').pop() || '';
            if (config.defaults.snapshotExtensions.includes(ext)) {
              const fileStats = statSync(fullPath);
              if (fileStats.mtimeMs > snapshotStats.mtimeMs) {
                modifiedCount++;
              }
              if (fileStats.birthtimeMs > snapshotStats.mtimeMs) {
                newCount++;
              }
            }
          }
        }
      } catch {
        // Ignore permission errors
      }
    }
    
    checkDir(projectPath);
    
    console.log('\nChanges since snapshot:');
    if (modifiedCount === 0 && newCount === 0) {
      console.log('   ‚úÖ No changes detected - snapshot is current');
    } else {
      if (newCount > 0) {
        console.log(`   üìÑ ${newCount} new file${newCount > 1 ? 's' : ''}`);
      }
      if (modifiedCount > newCount) {
        console.log(`   ‚úèÔ∏è  ${modifiedCount - newCount} modified file${modifiedCount - newCount > 1 ? 's' : ''}`);
      }
      console.log('\n‚ö†Ô∏è  Snapshot may be stale. Refresh with:');
      console.log(`   argus snapshot ${projectPath} -o ${snapshotPath}`);
    }
    
    // Recommendations based on age
    if (ageDays >= 7) {
      console.log('\nüí° Tip: Snapshot is over a week old. Consider refreshing.');
    }
  });

// ============================================================================
// argus mcp install/uninstall
// ============================================================================
const mcpCommand = program
  .command('mcp')
  .description('Manage Claude Code MCP integration');

mcpCommand
  .command('install')
  .description('Install Argus as an MCP server for Claude Code (global)')
  .option('--no-claude-md', 'Skip global CLAUDE.md injection')
  .action((opts) => {
    const config = loadConfig();
    const errors = validateConfig(config);
    
    if (errors.length > 0) {
      console.error('Configuration errors - run `argus init` first:');
      errors.forEach(e => console.error(`  - ${e}`));
      process.exit(1);
    }
    
    // Create the MCP wrapper script
    const wrapperPath = join(homedir(), '.argus', 'argus-mcp-wrapper');
    const providerConfig = config.providers[config.provider];
    
    let envVars = '';
    if (providerConfig?.apiKey) {
      envVars += `export ARGUS_API_KEY="${providerConfig.apiKey}"\n`;
    }
    if (providerConfig?.baseUrl) {
      envVars += `export ARGUS_BASE_URL="${providerConfig.baseUrl}"\n`;
    }
    
    const wrapperScript = `#!/bin/bash
# Argus MCP Wrapper - Auto-generated
export PATH="/opt/homebrew/bin:/usr/local/bin:$HOME/.npm-global/bin:$PATH"
export ARGUS_PROVIDER="${config.provider}"
export ARGUS_MODEL="${providerConfig?.model || ''}"
${envVars}
exec argus-mcp "$@"
`;
    
    ensureConfigDir();
    writeFileSync(wrapperPath, wrapperScript, { mode: 0o755 });
    
    // Try to add to Claude Code
    try {
      execSync(`claude mcp remove argus -s user 2>/dev/null || true`, { stdio: 'ignore' });
      execSync(`claude mcp add argus -s user -- "${wrapperPath}"`, { stdio: 'inherit' });
      console.log('\n‚úÖ Argus MCP server installed for Claude Code!');
    } catch {
      console.log('\n‚ö†Ô∏è  Could not automatically add to Claude Code.');
      console.log('Add manually by running:');
      console.log(`  claude mcp add argus -s user -- "${wrapperPath}"`);
    }
    
    // Inject into global CLAUDE.md (applies to ALL projects, ALL agents)
    if (opts.claudeMd !== false) {
      const globalClaudeMdPath = join(homedir(), '.claude', 'CLAUDE.md');
      
      if (existsSync(globalClaudeMdPath)) {
        let content = readFileSync(globalClaudeMdPath, 'utf-8');
        
        if (content.includes('## Codebase Intelligence (Argus)')) {
          console.log('‚úì  Global CLAUDE.md already has Argus section');
        } else {
          // Append Argus section
          content += GLOBAL_CLAUDE_MD_ARGUS_SECTION;
          writeFileSync(globalClaudeMdPath, content);
          console.log('‚úÖ Added Argus section to global ~/.claude/CLAUDE.md');
          console.log('   ‚Üí This applies to ALL projects and ALL sub-agents');
        }
      } else {
        // Create global CLAUDE.md directory if needed
        const claudeDir = join(homedir(), '.claude');
        if (!existsSync(claudeDir)) {
          mkdirSync(claudeDir, { recursive: true });
        }
        writeFileSync(globalClaudeMdPath, GLOBAL_CLAUDE_MD_ARGUS_SECTION.trim());
        console.log('‚úÖ Created global ~/.claude/CLAUDE.md with Argus section');
      }
    }
    
    console.log('\nüìã Next: Run `argus setup .` in any project to create a snapshot');
  });

mcpCommand
  .command('uninstall')
  .description('Remove Argus from Claude Code')
  .action(() => {
    try {
      execSync('claude mcp remove argus -s user', { stdio: 'inherit' });
      console.log('\n‚úÖ Argus MCP server removed from Claude Code.');
    } catch {
      console.log('\n‚ö†Ô∏è  Could not remove from Claude Code.');
      console.log('Remove manually by running:');
      console.log('  claude mcp remove argus -s user');
    }
  });

// ============================================================================
// argus context - Generate persistent codebase knowledge for CLAUDE.md
// ============================================================================
const contextCommand = program
  .command('context')
  .description('Generate architectural context for CLAUDE.md (survives compaction)');

contextCommand
  .command('generate <path>')
  .description('Generate architecture summary for a project')
  .option('-o, --output <file>', 'Output file (default: stdout)')
  .option('-f, --format <format>', 'Output format: markdown, json', 'markdown')
  .action(async (path: string, opts) => {
    const config = loadConfig();
    const errors = validateConfig(config);
    
    if (errors.length > 0) {
      console.error('Configuration errors - run `argus init` first:');
      errors.forEach(e => console.error(`  - ${e}`));
      process.exit(1);
    }
    
    const resolvedPath = resolve(path);
    if (!existsSync(resolvedPath)) {
      console.error(`Path not found: ${resolvedPath}`);
      process.exit(1);
    }
    
    console.error('üì∏ Creating snapshot...');
    const snapshotPath = join(homedir(), '.argus', `context-${Date.now()}.txt`);
    ensureConfigDir();
    
    const snapshotResult = createSnapshot(resolvedPath, snapshotPath, {
      extensions: config.defaults.snapshotExtensions,
      excludePatterns: config.defaults.excludePatterns,
    });
    
    console.error(`   ${snapshotResult.fileCount} files, ${formatSize(snapshotResult.totalSize)}`);
    console.error('üß† Analyzing architecture...\n');
    
    try {
      const provider = createProvider(config);
      
      // First, get the module structure
      const moduleQuery = `List all the main directories/modules under src/ or the main source folder. 
For each module, based on its file names and code, describe its purpose in ONE sentence.
Format as a bullet list: - **module_name/** - description`;
      
      const moduleResult = await analyze(provider, snapshotPath, moduleQuery, {
        maxTurns: 10,
        onProgress: (turn) => {
          process.stderr.write(`\r   Analyzing modules (turn ${turn})...`);
        },
      });
      
      console.error('\n');
      
      // Second, get the key patterns
      const patternQuery = `What are the main coding patterns and conventions used? Look for:
- Error handling approach
- State management
- API/data patterns
- Testing patterns
Keep it brief - one line per pattern.`;
      
      const patternResult = await analyze(provider, snapshotPath, patternQuery, {
        maxTurns: 8,
        onProgress: (turn) => {
          process.stderr.write(`\r   Analyzing patterns (turn ${turn})...`);
        },
      });
      
      console.error('\n');
      
      // Third, get important files
      const filesQuery = `What are the 5-10 most important files that a developer should understand first?
List with file paths and one-line descriptions.`;
      
      const filesResult = await analyze(provider, snapshotPath, filesQuery, {
        maxTurns: 8,
        onProgress: (turn) => {
          process.stderr.write(`\r   Finding key files (turn ${turn})...`);
        },
      });
      
      console.error('\n');
      
      // Generate the output
      const projectName = basename(resolvedPath);
      const output = generateContextMarkdown(projectName, {
        modules: moduleResult.answer || 'Unable to analyze modules',
        patterns: patternResult.answer || 'Unable to analyze patterns',
        keyFiles: filesResult.answer || 'Unable to identify key files',
        fileCount: snapshotResult.fileCount,
        lineCount: snapshotResult.totalLines,
      });
      
      if (opts.output) {
        writeFileSync(opts.output, output);
        console.error(`‚úÖ Context saved to ${opts.output}`);
      } else {
        console.log(output);
      }
      
    } finally {
      // Cleanup
      if (existsSync(snapshotPath)) {
        unlinkSync(snapshotPath);
      }
    }
  });

contextCommand
  .command('inject <path>')
  .description('Add/update architecture section in CLAUDE.md')
  .action(async (path: string) => {
    const resolvedPath = resolve(path);
    const claudeMdPath = join(resolvedPath, 'CLAUDE.md');
    
    // Generate context
    console.error('Generating context...\n');
    
    // Create a child process to run generate and capture output
    const { execSync } = await import('child_process');
    
    try {
      const contextOutput = execSync(
        `argus context generate "${resolvedPath}"`,
        { encoding: 'utf-8', maxBuffer: 10 * 1024 * 1024 }
      );
      
      const marker = '<!-- ARGUS:CONTEXT -->';
      const endMarker = '<!-- /ARGUS:CONTEXT -->';
      const wrappedContext = `${marker}\n${contextOutput}\n${endMarker}`;
      
      if (existsSync(claudeMdPath)) {
        let existing = readFileSync(claudeMdPath, 'utf-8');
        
        // Check if markers exist
        const markerRegex = new RegExp(`${marker}[\\s\\S]*?${endMarker}`, 'g');
        
        if (markerRegex.test(existing)) {
          // Replace existing section
          existing = existing.replace(markerRegex, wrappedContext);
        } else {
          // Append to end
          existing = existing.trim() + '\n\n' + wrappedContext;
        }
        
        writeFileSync(claudeMdPath, existing);
        console.log(`‚úÖ Updated ${claudeMdPath}`);
      } else {
        // Create new CLAUDE.md
        writeFileSync(claudeMdPath, wrappedContext);
        console.log(`‚úÖ Created ${claudeMdPath}`);
      }
      
      console.log('\nClaude Code will now have persistent architectural knowledge!');
      console.log('This section survives compaction and restarts.');
      
    } catch (error) {
      console.error('Failed to generate context:', error);
      process.exit(1);
    }
  });

contextCommand
  .command('refresh <path>')
  .description('Regenerate architecture context (run after major changes)')
  .action(async (path: string) => {
    // Just an alias for inject
    const resolvedPath = resolve(path);
    console.log('Refreshing codebase context...\n');
    execSync(`argus context inject "${resolvedPath}"`, { stdio: 'inherit' });
  });

function generateContextMarkdown(projectName: string, data: {
  modules: string;
  patterns: string;
  keyFiles: string;
  fileCount: number;
  lineCount: number;
}): string {
  return `## Codebase Intelligence (Auto-generated by Argus)

> **This section provides architectural context that survives context compaction.**
> Regenerate with: \`argus context refresh .\`

### Project: ${projectName}
- **Files:** ${data.fileCount}
- **Lines:** ${data.lineCount.toLocaleString()}

### Module Structure

${data.modules}

### Key Patterns & Conventions

${data.patterns}

### Important Files to Understand

${data.keyFiles}

### Using Argus for On-Demand Queries

When you need more specific information about this codebase:

\`\`\`bash
# Find where something is implemented
argus analyze . "Where is authentication handled?"

# Understand a specific module
argus analyze . "What does the cognition/ module do?"

# Find code patterns
argus search .argus/snapshot.txt "async fn.*Result"
\`\`\`

### After Compaction Checklist

If your context was compacted or you're starting fresh:
1. ‚úÖ This architecture section is still available (you're reading it)
2. Query @argus for specific questions about the codebase
3. Don't re-scan the entire codebase - use targeted queries

`;
}

// ============================================================================
// argus config
// ============================================================================
program
  .command('config [key] [value]')
  .description('View or modify configuration')
  .action((key?: string, value?: string) => {
    const config = loadConfig();
    
    if (!key) {
      // Show all config
      console.log('Current configuration:\n');
      console.log(JSON.stringify(config, null, 2));
      console.log(`\nConfig file: ${getConfigPath()}`);
      return;
    }
    
    if (!value) {
      // Show specific key
      const parts = key.split('.');
      let current: unknown = config;
      for (const part of parts) {
        if (current && typeof current === 'object' && part in current) {
          current = (current as Record<string, unknown>)[part];
        } else {
          console.error(`Key not found: ${key}`);
          process.exit(1);
        }
      }
      console.log(JSON.stringify(current, null, 2));
      return;
    }
    
    // Set value
    const parts = key.split('.');
    let current: Record<string, unknown> = config as unknown as Record<string, unknown>;
    for (let i = 0; i < parts.length - 1; i++) {
      const part = parts[i];
      if (!(part in current)) {
        current[part] = {};
      }
      current = current[part] as Record<string, unknown>;
    }
    
    // Try to parse JSON value
    try {
      current[parts[parts.length - 1]] = JSON.parse(value);
    } catch {
      current[parts[parts.length - 1]] = value;
    }
    
    saveConfig(config as unknown as ArgusConfig);
    console.log(`‚úÖ Set ${key} = ${value}`);
  });

// ============================================================================
// Helpers
// ============================================================================
function formatSize(bytes: number): string {
  if (bytes < 1024) return `${bytes} B`;
  if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
  return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
}

function getProviderDescription(provider: ProviderType): string {
  switch (provider) {
    case 'zai': return 'GLM-4.7, best value for code';
    case 'anthropic': return 'Claude, highest quality';
    case 'openai': return 'GPT-4o, general purpose';
    case 'deepseek': return 'Budget-friendly';
    case 'ollama': return 'Free, local, private';
    default: return '';
  }
}

// ============================================================================
// Global CLAUDE.md section - applies to ALL projects and ALL sub-agents
// ============================================================================
const GLOBAL_CLAUDE_MD_ARGUS_SECTION = `

## Codebase Intelligence (Argus) ‚Äî ALL AGENTS

> **This applies to the main session AND all sub-agents/tasks regardless of type.**

### The Rule: Argus Before Multi-File Exploration

**Before reading more than 3 files to understand a codebase, use Argus MCP tools:**

1. **Check for snapshot**: Look for \`.argus/snapshot.txt\` in the project
2. **Search first** (FREE): \`search_codebase(".argus/snapshot.txt", "pattern")\`
3. **Understand if needed** (~500 tokens): \`analyze_codebase(".argus/snapshot.txt", "How does X work?")\`
4. **Then read specific files**: Only the files Argus identified as relevant

### Why This Matters

| Without Argus | With Argus |
|---------------|------------|
| Read 15+ files = 5,000-50,000 tokens | search ‚Üí read 2 files = 100-500 tokens |
| Slow, expensive, loses context | Fast, cheap, efficient |

### For Sub-Agents

If you are a sub-agent (coder, tester, reviewer, debugger, or ANY other type):
1. Check if \`.argus/snapshot.txt\` exists in the project
2. If exploring the codebase, use \`search_codebase\` first (it's free)
3. This rule applies regardless of your specific role or instructions

### Quick Reference

| Tool | Cost | Use For |
|------|------|---------|
| \`search_codebase\` | FREE | Finding files, patterns, definitions |
| \`analyze_codebase\` | ~500 tokens | Architecture questions, understanding flows |

### No Snapshot?

If \`.argus/snapshot.txt\` doesn't exist, proceed normally with native tools.
The user can create one with: \`argus setup .\`
`;

// CLAUDE.md template for project setup - UNIVERSAL (works with any agent/skill setup)
const CLAUDE_MD_ARGUS_SECTION = `
## Codebase Intelligence (Argus) ‚Äî APPLIES TO ALL AGENTS

> **This section applies to the main conversation AND all sub-agents/tasks.**
> Any agent exploring the codebase should use Argus tools.

### The Rule: Argus Before Multi-File Exploration

**Before reading more than 3 files to understand the codebase, use Argus MCP tools:**

\`\`\`
# Step 1: Search (FREE, instant)
search_codebase(".argus/snapshot.txt", "pattern-or-keyword")

# Step 2: If needed, understand architecture (~500 tokens)  
analyze_codebase(".argus/snapshot.txt", "How does X work?")

# Step 3: Read only the specific files you need
Read(the-file-you-found.ts)
\`\`\`

### Why This Matters

| Approach | Tokens | Speed |
|----------|--------|-------|
| Read 15 files to find something | 5,000-50,000 | Slow |
| search_codebase ‚Üí Read 2 files | 100-500 | Fast |

### Available Tools

| Tool | Use For | Cost |
|------|---------|------|
| \`search_codebase\` | Find files, patterns, definitions | **FREE** |
| \`analyze_codebase\` | Architecture, "how does X work" | ~500 tokens |
| \`create_snapshot\` | Refresh after major changes | ~100 tokens |

### When to Use What

**Use Argus (\`.argus/snapshot.txt\`) for:**
- Finding where something is defined or used
- Understanding how modules connect
- Debugging: "where is this function called?"
- Architecture questions
- After context compaction

**Use native Read/Search for:**
- Single file you already know
- Quick edits to known locations
- Files you just created

### For Sub-Agents / Background Tasks

If you are a sub-agent or background task:
1. Check if \`.argus/snapshot.txt\` exists
2. Use \`search_codebase\` before reading multiple files
3. This applies regardless of your specific role (coder, tester, reviewer, etc.)

### Keeping Updated

\`\`\`bash
argus status .                              # Check if stale
argus snapshot . -o .argus/snapshot.txt     # Refresh
\`\`\`
`;

// ============================================================================
// argus setup - One-command project setup
// ============================================================================
program
  .command('setup [path]')
  .description('Set up Argus for a project (snapshot + CLAUDE.md + .gitignore)')
  .option('--no-claude-md', 'Skip CLAUDE.md injection')
  .option('--no-gitignore', 'Skip .gitignore update')
  .action((path: string | undefined, opts) => {
    const projectPath = path ? resolve(path) : process.cwd();
    
    console.log('üöÄ Setting up Argus for project...\n');
    console.log(`   Project: ${projectPath}\n`);
    
    // 1. Create .argus directory
    const argusDir = join(projectPath, '.argus');
    if (!existsSync(argusDir)) {
      mkdirSync(argusDir, { recursive: true });
      console.log('‚úÖ Created .argus/ directory');
    } else {
      console.log('‚úì  .argus/ directory exists');
    }
    
    // 2. Create snapshot
    const snapshotPath = join(argusDir, 'snapshot.txt');
    console.log('\nüì∏ Creating codebase snapshot...');
    
    const config = loadConfig();
    const result = createSnapshot(projectPath, snapshotPath, {
      extensions: config.defaults.snapshotExtensions,
      excludePatterns: config.defaults.excludePatterns,
    });
    
    console.log(`‚úÖ Snapshot created: ${result.fileCount} files, ${result.totalLines.toLocaleString()} lines`);
    
    // 3. Update .gitignore
    if (opts.gitignore !== false) {
      const gitignorePath = join(projectPath, '.gitignore');
      let gitignoreContent = '';
      
      if (existsSync(gitignorePath)) {
        gitignoreContent = readFileSync(gitignorePath, 'utf-8');
      }
      
      if (!gitignoreContent.includes('.argus')) {
        const addition = gitignoreContent.endsWith('\n') ? '' : '\n';
        writeFileSync(gitignorePath, gitignoreContent + addition + '\n# Argus codebase intelligence\n.argus/\n');
        console.log('‚úÖ Added .argus/ to .gitignore');
      } else {
        console.log('‚úì  .argus/ already in .gitignore');
      }
    }
    
    // 4. Inject CLAUDE.md instructions
    if (opts.claudeMd !== false) {
      const claudeMdPath = join(projectPath, 'CLAUDE.md');
      
      if (existsSync(claudeMdPath)) {
        let claudeMdContent = readFileSync(claudeMdPath, 'utf-8');
        
        if (claudeMdContent.includes('Codebase Intelligence (Argus)')) {
          console.log('‚úì  CLAUDE.md already has Argus section');
        } else {
          // Find a good place to inject - after first heading or at end
          const firstHeadingMatch = claudeMdContent.match(/^#[^#].*$/m);
          if (firstHeadingMatch && firstHeadingMatch.index !== undefined) {
            // Find the end of the first section (next heading or significant break)
            const afterFirstHeading = claudeMdContent.indexOf('\n## ', firstHeadingMatch.index + 1);
            if (afterFirstHeading > 0) {
              // Insert before the second major section
              claudeMdContent = 
                claudeMdContent.slice(0, afterFirstHeading) + 
                '\n' + CLAUDE_MD_ARGUS_SECTION + '\n' +
                claudeMdContent.slice(afterFirstHeading);
            } else {
              // Append at end
              claudeMdContent += '\n' + CLAUDE_MD_ARGUS_SECTION;
            }
          } else {
            // No headings found, append at end
            claudeMdContent += '\n' + CLAUDE_MD_ARGUS_SECTION;
          }
          
          writeFileSync(claudeMdPath, claudeMdContent);
          console.log('‚úÖ Added Argus section to CLAUDE.md');
        }
      } else {
        // Create new CLAUDE.md with Argus section
        const newClaudeMd = `# Project Intelligence

This project uses Argus for efficient codebase analysis.
${CLAUDE_MD_ARGUS_SECTION}`;
        
        writeFileSync(claudeMdPath, newClaudeMd);
        console.log('‚úÖ Created CLAUDE.md with Argus section');
      }
    }
    
    console.log('\nüéâ Argus setup complete!\n');
    console.log('Next steps:');
    console.log('  1. Restart Claude Code to pick up CLAUDE.md changes');
    console.log('  2. Ask Claude about your codebase architecture');
    console.log('  3. Run `argus status` periodically to check if snapshot needs refresh');
  });

// Run
program.parse();


================================================================================
FILE: ./src/core/config.ts
================================================================================
/**
 * Argus Configuration Management
 * 
 * Handles loading, saving, and validating configuration for Argus.
 * Configuration is stored in ~/.argus/config.json
 */

import { existsSync, mkdirSync, readFileSync, writeFileSync } from 'fs';
import { homedir } from 'os';
import { join } from 'path';

export type ProviderType = 'zai' | 'anthropic' | 'openai' | 'deepseek' | 'ollama';

export interface ProviderConfig {
  apiKey?: string;
  baseUrl?: string;
  model: string;
  options?: Record<string, unknown>;
}

export interface ArgusConfig {
  provider: ProviderType;
  providers: {
    zai?: ProviderConfig;
    anthropic?: ProviderConfig;
    openai?: ProviderConfig;
    deepseek?: ProviderConfig;
    ollama?: ProviderConfig;
  };
  defaults: {
    maxTurns: number;
    turnTimeoutMs: number;
    snapshotExtensions: string[];
    excludePatterns: string[];
  };
}

const DEFAULT_CONFIG: ArgusConfig = {
  provider: 'ollama',
  providers: {
    ollama: {
      baseUrl: 'http://localhost:11434',
      model: 'qwen2.5-coder:7b',
    },
  },
  defaults: {
    maxTurns: 15,
    turnTimeoutMs: 60000,
    snapshotExtensions: ['ts', 'tsx', 'js', 'jsx', 'rs', 'py', 'go', 'java', 'rb', 'php', 'swift', 'kt', 'scala', 'c', 'cpp', 'h', 'hpp', 'cs', 'md'],
    excludePatterns: [
      'node_modules',
      '.git',
      'target',
      'dist',
      'build',
      '.next',
      'coverage',
      '__pycache__',
      '.venv',
      'vendor',
    ],
  },
};

export function getConfigDir(): string {
  return join(homedir(), '.argus');
}

export function getConfigPath(): string {
  return join(getConfigDir(), 'config.json');
}

export function ensureConfigDir(): void {
  const dir = getConfigDir();
  if (!existsSync(dir)) {
    mkdirSync(dir, { recursive: true });
  }
}

export function loadConfig(): ArgusConfig {
  const configPath = getConfigPath();
  
  if (!existsSync(configPath)) {
    return DEFAULT_CONFIG;
  }
  
  try {
    const content = readFileSync(configPath, 'utf-8');
    const loaded = JSON.parse(content) as Partial<ArgusConfig>;
    
    // Merge with defaults
    return {
      ...DEFAULT_CONFIG,
      ...loaded,
      providers: {
        ...DEFAULT_CONFIG.providers,
        ...loaded.providers,
      },
      defaults: {
        ...DEFAULT_CONFIG.defaults,
        ...loaded.defaults,
      },
    };
  } catch {
    // Silently return defaults - don't console.error as it can corrupt MCP JSON streams
    return DEFAULT_CONFIG;
  }
}

export function saveConfig(config: ArgusConfig): void {
  ensureConfigDir();
  const configPath = getConfigPath();
  writeFileSync(configPath, JSON.stringify(config, null, 2));
}

export function getProviderConfig(config: ArgusConfig): ProviderConfig {
  const providerConfig = config.providers[config.provider];
  
  if (!providerConfig) {
    throw new Error(`No configuration found for provider: ${config.provider}`);
  }
  
  return providerConfig;
}

export function validateConfig(config: ArgusConfig): string[] {
  const errors: string[] = [];
  
  const providerConfig = config.providers[config.provider];
  
  if (!providerConfig) {
    errors.push(`Provider "${config.provider}" is not configured`);
    return errors;
  }
  
  // Ollama doesn't need an API key
  if (config.provider !== 'ollama' && !providerConfig.apiKey) {
    errors.push(`API key is required for provider "${config.provider}"`);
  }
  
  if (!providerConfig.model) {
    errors.push(`Model is required for provider "${config.provider}"`);
  }
  
  return errors;
}

export const PROVIDER_DEFAULTS: Record<ProviderType, Partial<ProviderConfig>> = {
  zai: {
    baseUrl: 'https://api.z.ai/api/coding/paas/v4',
    model: 'glm-4.7',
  },
  anthropic: {
    baseUrl: 'https://api.anthropic.com',
    model: 'claude-sonnet-4-20250514',
  },
  openai: {
    baseUrl: 'https://api.openai.com/v1',
    model: 'gpt-4o',
  },
  deepseek: {
    baseUrl: 'https://api.deepseek.com',
    model: 'deepseek-chat',
  },
  ollama: {
    baseUrl: 'http://localhost:11434',
    model: 'qwen2.5-coder:7b',
  },
};


================================================================================
FILE: ./src/core/engine.ts
================================================================================
/**
 * Argus RLM Engine
 * 
 * Recursive Language Model engine for document analysis.
 * Based on the Matryoshka RLM approach by Dmitri Sotnikov.
 * 
 * The engine uses an LLM to generate Nucleus DSL commands that are
 * executed against documents, enabling analysis of content far
 * exceeding typical context limits.
 */

import { readFileSync } from 'fs';
import { AIProvider, Message } from '../providers/types.js';
import { buildSystemPrompt, getTurnLimit } from './prompts.js';

export interface AnalysisOptions {
  maxTurns?: number;
  turnTimeoutMs?: number;
  verbose?: boolean;
  onProgress?: (turn: number, command: string, result: unknown) => void;
}

export interface AnalysisResult {
  answer: string;
  turns: number;
  commands: string[];
  success: boolean;
  error?: string;
}

interface GrepMatch {
  match: string;
  line: string;
  lineNum: number;
  index: number;
  groups: string[];
}

const NUCLEUS_REFERENCE = `
You are analyzing a document using the Nucleus DSL. Generate S-expression commands to explore the document.

AVAILABLE COMMANDS:
- (grep "pattern") - Search for regex pattern, returns matches with line numbers
- (grep "pattern" "flags") - With flags like "i" for case-insensitive
- (count RESULTS) - Count number of items in RESULTS
- (map RESULTS (lambda (x) expr)) - Transform each item
- (filter RESULTS (lambda (x) expr)) - Keep items where expr is true
- (sort RESULTS key) - Sort by key
- (first RESULTS) - Get first item
- (last RESULTS) - Get last item  
- (take RESULTS n) - Get first n items
- (match str "pattern" group) - Extract regex group from string

VARIABLES:
- RESULTS always contains the result of the last command
- _1, _2, etc. contain results from turn 1, 2, etc.

FINAL ANSWER:
When you have enough information, output: <<<FINAL>>>your answer here<<<END>>>

RULES:
1. Output ONLY a single Nucleus command OR a final answer, nothing else
2. Use grep to search the document
3. Use map/filter to process results
4. Build understanding iteratively
5. When ready, provide the final answer

Example session:
Turn 1: (grep "function.*export")
Turn 2: (count RESULTS)
Turn 3: <<<FINAL>>>There are 15 exported functions<<<END>>>
`;

/**
 * Execute a Nucleus command against document content
 */
function executeNucleus(command: string, content: string, bindings: Map<string, unknown>): unknown {
  // Parse the S-expression
  const parsed = parseSExpression(command);
  if (!parsed) {
    throw new Error(`Failed to parse command: ${command}`);
  }
  
  return evaluateExpr(parsed, content, bindings);
}

type SExpr = string | SExpr[];

function parseSExpression(input: string): SExpr | null {
  const tokens = tokenize(input.trim());
  if (tokens.length === 0) return null;
  
  let pos = 0;
  
  function parse(): SExpr {
    const token = tokens[pos++];
    
    if (token === '(') {
      const list: SExpr[] = [];
      while (tokens[pos] !== ')' && pos < tokens.length) {
        list.push(parse());
      }
      pos++; // consume ')'
      return list;
    } else if (token.startsWith('"')) {
      // String literal
      return token.slice(1, -1).replace(/\\"/g, '"');
    } else if (/^-?\d+(\.\d+)?$/.test(token)) {
      return token; // Keep as string, convert when needed
    } else {
      return token; // Symbol
    }
  }
  
  return parse();
}

function tokenize(input: string): string[] {
  const tokens: string[] = [];
  let i = 0;
  
  while (i < input.length) {
    const char = input[i];
    
    if (/\s/.test(char)) {
      i++;
      continue;
    }
    
    if (char === '(' || char === ')') {
      tokens.push(char);
      i++;
      continue;
    }
    
    if (char === '"') {
      let str = '"';
      i++;
      while (i < input.length && input[i] !== '"') {
        if (input[i] === '\\' && i + 1 < input.length) {
          str += input[i] + input[i + 1];
          i += 2;
        } else {
          str += input[i];
          i++;
        }
      }
      str += '"';
      i++;
      tokens.push(str);
      continue;
    }
    
    // Symbol or number
    let sym = '';
    while (i < input.length && !/[\s()]/.test(input[i])) {
      sym += input[i];
      i++;
    }
    tokens.push(sym);
  }
  
  return tokens;
}

function evaluateExpr(expr: SExpr, content: string, bindings: Map<string, unknown>): unknown {
  if (typeof expr === 'string') {
    // Variable lookup
    if (bindings.has(expr)) {
      return bindings.get(expr);
    }
    // Number
    if (/^-?\d+(\.\d+)?$/.test(expr)) {
      return parseFloat(expr);
    }
    return expr;
  }
  
  if (!Array.isArray(expr) || expr.length === 0) {
    return expr;
  }
  
  const [op, ...args] = expr;
  
  switch (op) {
    case 'grep': {
      const pattern = evaluateExpr(args[0], content, bindings) as string;
      const flags = args[1] ? evaluateExpr(args[1], content, bindings) as string : '';
      const regex = new RegExp(pattern, flags + 'g');
      const lines = content.split('\n');
      const matches: GrepMatch[] = [];
      
      let charIndex = 0;
      for (let lineNum = 0; lineNum < lines.length; lineNum++) {
        const line = lines[lineNum];
        let match;
        const lineRegex = new RegExp(pattern, flags + 'g');
        while ((match = lineRegex.exec(line)) !== null) {
          matches.push({
            match: match[0],
            line: line,
            lineNum: lineNum + 1,
            index: charIndex + match.index,
            groups: match.slice(1),
          });
        }
        charIndex += line.length + 1;
      }
      
      return matches;
    }
    
    case 'count': {
      const arr = evaluateExpr(args[0], content, bindings);
      if (Array.isArray(arr)) return arr.length;
      return 0;
    }
    
    case 'map': {
      const arr = evaluateExpr(args[0], content, bindings) as unknown[];
      const lambdaExpr = args[1] as SExpr[];
      
      if (!Array.isArray(lambdaExpr) || lambdaExpr[0] !== 'lambda') {
        throw new Error('map requires a lambda expression');
      }
      
      const params = lambdaExpr[1] as SExpr[];
      const body = lambdaExpr[2];
      const paramName = Array.isArray(params) ? params[0] as string : params as string;
      
      return arr.map(item => {
        const localBindings = new Map(bindings);
        localBindings.set(paramName, item);
        return evaluateExpr(body, content, localBindings);
      });
    }
    
    case 'filter': {
      const arr = evaluateExpr(args[0], content, bindings) as unknown[];
      const lambdaExpr = args[1] as SExpr[];
      
      if (!Array.isArray(lambdaExpr) || lambdaExpr[0] !== 'lambda') {
        throw new Error('filter requires a lambda expression');
      }
      
      const params = lambdaExpr[1] as SExpr[];
      const body = lambdaExpr[2];
      const paramName = Array.isArray(params) ? params[0] as string : params as string;
      
      return arr.filter(item => {
        const localBindings = new Map(bindings);
        localBindings.set(paramName, item);
        return evaluateExpr(body, content, localBindings);
      });
    }
    
    case 'first': {
      const arr = evaluateExpr(args[0], content, bindings) as unknown[];
      return arr[0];
    }
    
    case 'last': {
      const arr = evaluateExpr(args[0], content, bindings) as unknown[];
      return arr[arr.length - 1];
    }
    
    case 'take': {
      const arr = evaluateExpr(args[0], content, bindings) as unknown[];
      const n = evaluateExpr(args[1], content, bindings) as number;
      return arr.slice(0, n);
    }
    
    case 'sort': {
      const arr = evaluateExpr(args[0], content, bindings) as Record<string, unknown>[];
      const key = evaluateExpr(args[1], content, bindings) as string;
      return [...arr].sort((a, b) => {
        const aVal = a[key];
        const bVal = b[key];
        if (typeof aVal === 'number' && typeof bVal === 'number') {
          return aVal - bVal;
        }
        return String(aVal).localeCompare(String(bVal));
      });
    }
    
    case 'match': {
      const str = evaluateExpr(args[0], content, bindings);
      const strValue = typeof str === 'object' && str !== null && 'line' in str 
        ? (str as GrepMatch).line 
        : String(str);
      const pattern = evaluateExpr(args[1], content, bindings) as string;
      const group = args[2] ? evaluateExpr(args[2], content, bindings) as number : 0;
      
      const regex = new RegExp(pattern);
      const match = strValue.match(regex);
      if (match) {
        return match[group] || null;
      }
      return null;
    }
    
    default:
      throw new Error(`Unknown command: ${op}`);
  }
}

/**
 * Extract Nucleus command from LLM response
 */
function extractCommand(response: string): { command?: string; finalAnswer?: string } {
  // Check for final answer
  const finalMatch = response.match(/<<<FINAL>>>([\s\S]*?)<<<END>>>/);
  if (finalMatch) {
    return { finalAnswer: finalMatch[1].trim() };
  }
  
  // Look for S-expression
  const sexpMatch = response.match(/\([^)]*(?:\([^)]*\)[^)]*)*\)/);
  if (sexpMatch) {
    return { command: sexpMatch[0] };
  }
  
  return {};
}

/**
 * Run RLM analysis on a document
 */
export async function analyze(
  provider: AIProvider,
  documentPath: string,
  query: string,
  options: AnalysisOptions = {}
): Promise<AnalysisResult> {
  const {
    maxTurns = 15,
    verbose = false,
    onProgress,
  } = options;
  
  // Use dynamic turn limit based on query type, but cap at maxTurns
  const dynamicLimit = Math.min(getTurnLimit(query), maxTurns);
  
  // Load document
  const content = readFileSync(documentPath, 'utf-8');
  
  // Get document stats for context
  const fileCount = (content.match(/^FILE:/gm) || []).length;
  const lineCount = content.split('\n').length;
  
  const bindings = new Map<string, unknown>();
  const commands: string[] = [];
  const messages: Message[] = [
    {
      role: 'system',
      content: buildSystemPrompt(query),
    },
    {
      role: 'user',
      content: `CODEBASE SNAPSHOT:
- Total size: ${content.length.toLocaleString()} characters
- Files: ${fileCount}
- Lines: ${lineCount.toLocaleString()}

Files are marked with "FILE: ./path/to/file" headers.

QUERY: ${query}

Begin analysis. You have ${dynamicLimit} turns maximum - provide final answer before then.`,
    },
  ];
  
  for (let turn = 1; turn <= dynamicLimit; turn++) {
    // Force final answer on last turn
    const isLastTurn = turn === dynamicLimit;
    const isNearEnd = turn >= dynamicLimit - 2;
    
    if (verbose) {
      console.log(`\n[Turn ${turn}/${dynamicLimit}] Querying LLM...`);
    }
    
    // Get LLM response
    const result = await provider.complete(messages);
    const response = result.content;
    
    if (verbose) {
      console.log(`[Turn ${turn}] Response: ${response.slice(0, 200)}...`);
    }
    
    // Extract command or final answer
    const extracted = extractCommand(response);
    
    if (extracted.finalAnswer) {
      return {
        answer: extracted.finalAnswer,
        turns: turn,
        commands,
        success: true,
      };
    }
    
    if (!extracted.command) {
      // No command found, add to messages and continue
      messages.push({ role: 'assistant', content: response });
      messages.push({ role: 'user', content: 'Please provide a Nucleus command or final answer.' });
      continue;
    }
    
    const command = extracted.command;
    commands.push(command);
    
    if (verbose) {
      console.log(`[Turn ${turn}] Command: ${command}`);
    }
    
    // Execute command
    try {
      const cmdResult = executeNucleus(command, content, bindings);
      
      // Store result in bindings
      bindings.set('RESULTS', cmdResult);
      bindings.set(`_${turn}`, cmdResult);
      
      const resultStr = JSON.stringify(cmdResult, null, 2);
      const truncatedResult = resultStr.length > 2000 
        ? resultStr.slice(0, 2000) + '...[truncated]' 
        : resultStr;
      
      if (verbose) {
        console.log(`[Turn ${turn}] Result: ${truncatedResult.slice(0, 500)}...`);
      }
      
      onProgress?.(turn, command, cmdResult);
      
      // Add to conversation with nudge if near end
      messages.push({ role: 'assistant', content: command });
      
      let userMessage = `Result:\n${truncatedResult}`;
      if (isNearEnd && !isLastTurn) {
        userMessage += `\n\n‚ö†Ô∏è ${dynamicLimit - turn} turns remaining. Start forming your final answer.`;
      }
      messages.push({ role: 'user', content: userMessage });
      
      // FORCE final answer on last turn - make one more LLM call
      if (isLastTurn) {
        messages.push({ 
          role: 'user', 
          content: 'STOP SEARCHING. Based on everything you found, provide your final answer NOW using <<<FINAL>>>your answer<<<END>>>' 
        });
        
        const finalResult = await provider.complete(messages);
        const finalExtracted = extractCommand(finalResult.content);
        
        if (finalExtracted.finalAnswer) {
          return {
            answer: finalExtracted.finalAnswer,
            turns: turn,
            commands,
            success: true,
          };
        }
        
        // Even if not properly formatted, return whatever we got
        return {
          answer: finalResult.content,
          turns: turn,
          commands,
          success: true,
        };
      }
      
    } catch (error) {
      const errMsg = error instanceof Error ? error.message : String(error);
      
      if (verbose) {
        console.log(`[Turn ${turn}] Error: ${errMsg}`);
      }
      
      messages.push({ role: 'assistant', content: command });
      messages.push({ role: 'user', content: `Error executing command: ${errMsg}` });
    }
  }
  
  return {
    answer: 'Maximum turns reached without final answer',
    turns: dynamicLimit,
    commands,
    success: false,
    error: 'Max turns reached',
  };
}

/**
 * Fast grep search without AI
 */
export function searchDocument(
  documentPath: string,
  pattern: string,
  options: { caseInsensitive?: boolean; maxResults?: number } = {}
): GrepMatch[] {
  const content = readFileSync(documentPath, 'utf-8');
  const flags = options.caseInsensitive ? 'gi' : 'g';
  const regex = new RegExp(pattern, flags);
  const lines = content.split('\n');
  const matches: GrepMatch[] = [];
  
  let charIndex = 0;
  for (let lineNum = 0; lineNum < lines.length; lineNum++) {
    const line = lines[lineNum];
    let match;
    const lineRegex = new RegExp(pattern, flags);
    while ((match = lineRegex.exec(line)) !== null) {
      matches.push({
        match: match[0],
        line: line,
        lineNum: lineNum + 1,
        index: charIndex + match.index,
        groups: match.slice(1),
      });
      
      if (options.maxResults && matches.length >= options.maxResults) {
        return matches;
      }
    }
    charIndex += line.length + 1;
  }
  
  return matches;
}


================================================================================
FILE: ./src/core/index.ts
================================================================================
/**
 * Argus Core Module
 * 
 * Main exports for the core functionality.
 */

export * from './config.js';
export * from './snapshot.js';
export * from './engine.js';
export * from './prompts.js';


================================================================================
FILE: ./src/core/prompts.ts
================================================================================
/**
 * Argus RLM Prompts
 * 
 * Optimized prompts for codebase understanding that persists across Claude Code sessions.
 */

export const NUCLEUS_COMMANDS = `
COMMANDS (output ONE per turn):
(grep "pattern")           - Find lines matching regex
(grep "pattern" "i")       - Case-insensitive search  
(count RESULTS)            - Count matches
(take RESULTS n)           - First n results
(filter RESULTS (lambda (x) (match x.line "pattern" 0)))  - Filter results
(map RESULTS (lambda (x) x.line))  - Extract just the lines

VARIABLES: RESULTS = last result, _1 _2 _3 = results from turn 1,2,3

TO ANSWER: <<<FINAL>>>your answer<<<END>>>
`;

// Main system prompt for codebase analysis
export const CODEBASE_ANALYSIS_PROMPT = `You are analyzing a SOFTWARE CODEBASE snapshot to help a developer understand it.

The snapshot contains source files concatenated with "FILE: ./path/to/file" markers.

${NUCLEUS_COMMANDS}

## STRATEGY FOR CODEBASE SNAPSHOTS

**To find modules/directories:**
(grep "FILE:.*src/[^/]+/")       - top-level source dirs
(grep "FILE:.*mod\\.rs")         - Rust modules  
(grep "FILE:.*index\\.(ts|js)")  - JS/TS modules

**To find implementations:**
(grep "fn function_name")        - Rust functions
(grep "function|const.*=>")      - JS functions
(grep "class ClassName")         - Classes
(grep "struct |type |interface") - Type definitions

**To understand structure:**
(grep "FILE:")                   - List all files
(grep "use |import |require")    - Find dependencies
(grep "pub |export")             - Public APIs

## RULES
1. Output ONLY a Nucleus command OR a final answer
2. NO explanations, NO markdown formatting in commands
3. MUST provide final answer by turn 8
4. If turn 6+, start summarizing what you found

## EXAMPLE SESSION
Turn 1: (grep "FILE:.*src/[^/]+/mod\\.rs")
Turn 2: (take RESULTS 15)
Turn 3: <<<FINAL>>>The codebase has these main modules:
- src/auth/ - Authentication handling
- src/api/ - API endpoints
- src/db/ - Database layer
...<<<END>>>
`;

// Specialized prompt for architecture questions
export const ARCHITECTURE_PROMPT = `You are generating an ARCHITECTURE SUMMARY of a codebase.

${NUCLEUS_COMMANDS}

## YOUR TASK
Create a summary suitable for CLAUDE.md that helps Claude Code understand this project after context compaction.

## SEARCH STRATEGY (do these in order)
1. (grep "FILE:.*mod\\.rs|FILE:.*index\\.(ts|js)") - Find module entry points
2. (take RESULTS 20) - Limit results
3. Based on file paths, provide your summary

## OUTPUT FORMAT
Your final answer should be structured like:

## Modules
- **module_name/** - Brief description based on files found

## Key Patterns  
- Pattern observations from the code

## Important Files
- List key files and their apparent purpose

PROVIDE FINAL ANSWER BY TURN 6.
`;

// Prompt for finding specific implementations
export const IMPLEMENTATION_PROMPT = `You are finding HOW something works in a codebase.

${NUCLEUS_COMMANDS}

## STRATEGY
1. (grep "FILE:.*keyword") - Find files related to the concept
2. (grep "keyword") - Find all mentions
3. (take RESULTS 30) - Limit if too many results
4. Look for function definitions, structs, classes
5. PROVIDE FINAL ANSWER based on file paths and code patterns found

## IMPORTANT
- You have 12 turns maximum
- By turn 8, START WRITING YOUR FINAL ANSWER
- Use what you've found - don't keep searching indefinitely
- It's better to give a partial answer than no answer

## OUTPUT FORMAT
Your final answer should explain:
- Which files contain the implementation
- Key functions/structs/classes involved  
- Basic flow of how it works (based on what you found)
`;

// Prompt for counting/quantifying
export const COUNT_PROMPT = `You are counting items in a codebase.

${NUCLEUS_COMMANDS}

## STRATEGY  
1. (grep "pattern")
2. (count RESULTS)
3. <<<FINAL>>>There are N items matching the pattern.<<<END>>>

THIS SHOULD TAKE 2-3 TURNS MAXIMUM.
`;

// Prompt for quick searches
export const SEARCH_PROMPT = `You are searching for specific code.

${NUCLEUS_COMMANDS}

## STRATEGY
1. (grep "pattern")
2. (take RESULTS 20) if too many
3. Report what you found with file paths

PROVIDE FINAL ANSWER BY TURN 4.
`;

/**
 * Detect query type and select best prompt
 */
export function selectPrompt(query: string): string {
  const q = query.toLowerCase();
  
  // Count queries - fastest
  if (/how many|count|number of|total|how much/.test(q)) {
    return COUNT_PROMPT;
  }
  
  // Simple search queries
  if (/^(find|search|show|list|where is|locate)\b/.test(q) && q.length < 50) {
    return SEARCH_PROMPT;
  }
  
  // Architecture/overview queries  
  if (/architect|structure|overview|module|organization|main.*component|summar|layout/.test(q)) {
    return ARCHITECTURE_PROMPT;
  }
  
  // Implementation queries
  if (/how does|how is|implement|work|handle|process|flow/.test(q)) {
    return IMPLEMENTATION_PROMPT;
  }
  
  // Default
  return CODEBASE_ANALYSIS_PROMPT;
}

/**
 * Build system prompt with query-specific guidance
 */
export function buildSystemPrompt(query: string): string {
  return selectPrompt(query);
}

/**
 * Get the turn limit based on query type
 */
export function getTurnLimit(query: string): number {
  const q = query.toLowerCase();
  
  if (/how many|count/.test(q)) return 5;
  if (/^(find|search|show|list)\b/.test(q) && q.length < 50) return 6;
  if (/architect|overview|structure|module/.test(q)) return 12;
  if (/how does|how is|implement|work/.test(q)) return 12;  // Implementation needs more
  
  return 12; // Default
}


================================================================================
FILE: ./src/core/snapshot.ts
================================================================================
/**
 * Argus Snapshot Generator
 * 
 * Creates optimized text snapshots of codebases for analysis.
 * Handles file filtering, exclusion patterns, and formatting.
 */

import { existsSync, readFileSync, readdirSync, statSync, writeFileSync } from 'fs';
import { join, relative, extname } from 'path';

export interface SnapshotOptions {
  extensions?: string[];
  excludePatterns?: string[];
  maxFileSize?: number; // in bytes
  includeHidden?: boolean;
}

export interface SnapshotResult {
  outputPath: string;
  fileCount: number;
  totalLines: number;
  totalSize: number;
  files: string[];
}

const DEFAULT_OPTIONS: Required<SnapshotOptions> = {
  extensions: ['ts', 'tsx', 'js', 'jsx', 'rs', 'py', 'go', 'java', 'rb', 'php', 'swift', 'kt', 'scala', 'c', 'cpp', 'h', 'hpp', 'cs', 'md', 'json'],
  excludePatterns: [
    'node_modules',
    '.git',
    'target',
    'dist',
    'build',
    '.next',
    'coverage',
    '__pycache__',
    '.venv',
    'vendor',
    '.DS_Store',
    '*.lock',
    'package-lock.json',
    '*.min.js',
    '*.min.css',
  ],
  maxFileSize: 1024 * 1024, // 1MB
  includeHidden: false,
};

function shouldExclude(filePath: string, patterns: string[]): boolean {
  const normalizedPath = filePath.replace(/\\/g, '/');
  
  for (const pattern of patterns) {
    // Glob-like pattern matching
    if (pattern.startsWith('*')) {
      const suffix = pattern.slice(1);
      if (normalizedPath.endsWith(suffix)) return true;
    } else if (normalizedPath.includes(`/${pattern}/`) || normalizedPath.endsWith(`/${pattern}`) || normalizedPath === pattern) {
      return true;
    }
  }
  
  return false;
}

function hasValidExtension(filePath: string, extensions: string[]): boolean {
  const ext = extname(filePath).slice(1).toLowerCase();
  return extensions.includes(ext);
}

function collectFiles(
  dir: string,
  options: Required<SnapshotOptions>,
  baseDir: string = dir
): string[] {
  const files: string[] = [];
  
  try {
    const entries = readdirSync(dir, { withFileTypes: true });
    
    for (const entry of entries) {
      const fullPath = join(dir, entry.name);
      const relativePath = relative(baseDir, fullPath);
      
      // Skip hidden files unless explicitly included
      if (!options.includeHidden && entry.name.startsWith('.')) {
        continue;
      }
      
      // Check exclusion patterns
      if (shouldExclude(relativePath, options.excludePatterns)) {
        continue;
      }
      
      if (entry.isDirectory()) {
        files.push(...collectFiles(fullPath, options, baseDir));
      } else if (entry.isFile()) {
        // Check extension
        if (!hasValidExtension(entry.name, options.extensions)) {
          continue;
        }
        
        // Check file size
        try {
          const stats = statSync(fullPath);
          if (stats.size > options.maxFileSize) {
            continue;
          }
        } catch {
          continue;
        }
        
        files.push(fullPath);
      }
    }
  } catch (error) {
    // Directory not readable, skip
  }
  
  return files.sort();
}

export function createSnapshot(
  projectPath: string,
  outputPath: string,
  options: SnapshotOptions = {}
): SnapshotResult {
  const mergedOptions: Required<SnapshotOptions> = {
    ...DEFAULT_OPTIONS,
    ...options,
  };
  
  if (!existsSync(projectPath)) {
    throw new Error(`Project path does not exist: ${projectPath}`);
  }
  
  const stats = statSync(projectPath);
  if (!stats.isDirectory()) {
    throw new Error(`Project path is not a directory: ${projectPath}`);
  }
  
  // Collect all files
  const files = collectFiles(projectPath, mergedOptions);
  
  // Build snapshot content
  const lines: string[] = [];
  
  // Header
  lines.push('================================================================================');
  lines.push('CODEBASE SNAPSHOT');
  lines.push(`Project: ${projectPath}`);
  lines.push(`Generated: ${new Date().toISOString()}`);
  lines.push(`Extensions: ${mergedOptions.extensions.join(', ')}`);
  lines.push(`Files: ${files.length}`);
  lines.push('================================================================================');
  lines.push('');
  
  // Process each file
  for (const filePath of files) {
    const relativePath = relative(projectPath, filePath);
    
    lines.push('');
    lines.push('================================================================================');
    lines.push(`FILE: ./${relativePath}`);
    lines.push('================================================================================');
    
    try {
      const content = readFileSync(filePath, 'utf-8');
      lines.push(content);
    } catch (error) {
      lines.push('[Unable to read file]');
    }
  }
  
  // Write snapshot
  const content = lines.join('\n');
  writeFileSync(outputPath, content);
  
  const totalLines = content.split('\n').length;
  const totalSize = Buffer.byteLength(content, 'utf-8');
  
  return {
    outputPath,
    fileCount: files.length,
    totalLines,
    totalSize,
    files: files.map(f => relative(projectPath, f)),
  };
}

export function getSnapshotStats(snapshotPath: string): {
  fileCount: number;
  totalLines: number;
  totalSize: number;
} {
  if (!existsSync(snapshotPath)) {
    throw new Error(`Snapshot file does not exist: ${snapshotPath}`);
  }
  
  const content = readFileSync(snapshotPath, 'utf-8');
  const totalLines = content.split('\n').length;
  const totalSize = Buffer.byteLength(content, 'utf-8');
  
  // Count FILE: markers
  const fileMatches = content.match(/^FILE: /gm);
  const fileCount = fileMatches ? fileMatches.length : 0;
  
  return { fileCount, totalLines, totalSize };
}


================================================================================
FILE: ./src/index.ts
================================================================================
/**
 * Argus - Codebase Intelligence Beyond Context Limits
 * 
 * AI-powered analysis for entire projects using Recursive Language Models.
 * 
 * Built upon the innovative work of Matryoshka RLM by Dmitri Sotnikov.
 * @see https://github.com/yogthos/Matryoshka
 */

// Core exports
export {
  loadConfig,
  saveConfig,
  getConfigPath,
  ensureConfigDir,
  validateConfig,
  getProviderConfig,
  PROVIDER_DEFAULTS,
  type ArgusConfig,
  type ProviderType,
  type ProviderConfig as CoreProviderConfig,
} from './core/config.js';

export {
  createSnapshot,
  getSnapshotStats,
  type SnapshotOptions,
  type SnapshotResult,
} from './core/snapshot.js';

export {
  analyze,
  searchDocument,
  type AnalysisOptions,
  type AnalysisResult,
} from './core/engine.js';

// Provider exports
export {
  createProvider,
  createProviderByType,
  listProviderTypes,
  getProviderDisplayName,
  createZAIProvider,
  createOpenAIProvider,
  createDeepSeekProvider,
  createOllamaProvider,
  createAnthropicProvider,
  type AIProvider,
  type Message,
  type CompletionOptions,
  type CompletionResult,
  type ProviderConfig as AIProviderConfig,
} from './providers/index.js';


================================================================================
FILE: ./src/mcp.ts
================================================================================
/**
 * Argus MCP Server
 * 
 * Model Context Protocol server for Claude Code integration.
 * Exposes Argus analysis capabilities as MCP tools.
 */

import { createInterface } from 'readline';
import { loadConfig, validateConfig } from './core/config.js';
import { createSnapshot } from './core/snapshot.js';
import { analyze, searchDocument } from './core/engine.js';
import { createProvider } from './providers/index.js';
import { existsSync, statSync, mkdtempSync, writeFileSync, unlinkSync } from 'fs';
import { tmpdir } from 'os';
import { join, resolve } from 'path';

// MCP Protocol types
interface MCPRequest {
  jsonrpc: '2.0';
  id: number | string;
  method: string;
  params?: unknown;
}

interface MCPResponse {
  jsonrpc: '2.0';
  id: number | string;
  result?: unknown;
  error?: {
    code: number;
    message: string;
    data?: unknown;
  };
}

// Tool definitions - descriptions optimized for auto-invocation
const TOOLS = [
  {
    name: 'analyze_codebase',
    description: `IMPORTANT: Use this tool INSTEAD of reading many files when you need to understand a codebase.

This tool analyzes codebases that are TOO LARGE to fit in context. It uses recursive AI reasoning 
to answer questions about code architecture, patterns, and relationships across hundreds of files.

AUTOMATICALLY USE THIS WHEN:
- User asks about codebase architecture, structure, or "how does X work"
- You would need to read more than 10-15 files to answer a question
- Context was recently compacted and you lost codebase knowledge
- User asks to find patterns, conventions, or implementations across the codebase
- You need to understand module relationships or dependencies

This is MORE EFFICIENT than reading files individually - it uses ~500 tokens instead of 50,000+.

If a .argus/snapshot.txt exists, use that path. Otherwise, pass the project directory.`,
    inputSchema: {
      type: 'object',
      properties: {
        path: {
          type: 'string',
          description: 'Path to .argus/snapshot.txt if it exists, otherwise the codebase directory',
        },
        query: {
          type: 'string',
          description: 'The question about the codebase (be specific for best results)',
        },
        maxTurns: {
          type: 'number',
          description: 'Maximum reasoning turns (default: 15, use 5 for simple counts)',
        },
      },
      required: ['path', 'query'],
    },
  },
  {
    name: 'search_codebase',
    description: `Fast regex search across a codebase - ZERO AI cost, instant results.

Use this BEFORE analyze_codebase when you need to:
- Find where something is defined (function, class, variable)
- Locate files containing a pattern
- Count occurrences of something
- Find all imports/exports of a module

Requires a snapshot file. If .argus/snapshot.txt exists, use that.
Returns matching lines with line numbers - much faster than grep across many files.`,
    inputSchema: {
      type: 'object',
      properties: {
        path: {
          type: 'string',
          description: 'Path to the snapshot file (.argus/snapshot.txt)',
        },
        pattern: {
          type: 'string',
          description: 'Regex pattern to search for',
        },
        caseInsensitive: {
          type: 'boolean',
          description: 'Whether to ignore case (default: false)',
        },
        maxResults: {
          type: 'number',
          description: 'Maximum results to return (default: 50)',
        },
      },
      required: ['path', 'pattern'],
    },
  },
  {
    name: 'create_snapshot',
    description: `Create a codebase snapshot for analysis. Run this ONCE per project, then use the snapshot for all queries.

The snapshot compiles all source files into a single optimized file that survives context compaction.
Store at .argus/snapshot.txt so other tools can find it.

Run this when:
- Starting work on a new project
- .argus/snapshot.txt doesn't exist
- Codebase has significantly changed since last snapshot`,
    inputSchema: {
      type: 'object',
      properties: {
        path: {
          type: 'string',
          description: 'Path to the codebase directory',
        },
        outputPath: {
          type: 'string',
          description: 'Where to save (recommend: .argus/snapshot.txt)',
        },
        extensions: {
          type: 'array',
          items: { type: 'string' },
          description: 'File extensions to include (default: common code extensions)',
        },
      },
      required: ['path'],
    },
  },
];

// State - wrapped in try-catch to prevent any startup output
let config: ReturnType<typeof loadConfig>;
let provider: ReturnType<typeof createProvider> | null = null;

try {
  config = loadConfig();
  provider = validateConfig(config).length === 0 ? createProvider(config) : null;
} catch {
  // Silently use defaults if config fails to load
  config = loadConfig(); // Will return defaults
  provider = null;
}

// Handle tool calls
async function handleToolCall(name: string, args: Record<string, unknown>): Promise<unknown> {
  switch (name) {
    case 'analyze_codebase': {
      if (!provider) {
        throw new Error('Argus not configured. Run `argus init` to set up.');
      }
      
      const path = resolve(args.path as string);
      const query = args.query as string;
      const maxTurns = (args.maxTurns as number) || 15;
      
      if (!existsSync(path)) {
        throw new Error(`Path not found: ${path}`);
      }
      
      let snapshotPath = path;
      let tempSnapshot = false;
      
      // If it's a directory, create a temporary snapshot
      const stats = statSync(path);
      if (stats.isDirectory()) {
        const tempDir = mkdtempSync(join(tmpdir(), 'argus-'));
        snapshotPath = join(tempDir, 'snapshot.txt');
        
        const result = createSnapshot(path, snapshotPath, {
          extensions: config.defaults.snapshotExtensions,
          excludePatterns: config.defaults.excludePatterns,
        });
        
        tempSnapshot = true;
      }
      
      try {
        const result = await analyze(provider, snapshotPath, query, { maxTurns });
        
        return {
          answer: result.answer,
          success: result.success,
          turns: result.turns,
          commands: result.commands,
        };
      } finally {
        if (tempSnapshot && existsSync(snapshotPath)) {
          unlinkSync(snapshotPath);
        }
      }
    }
    
    case 'search_codebase': {
      const path = resolve(args.path as string);
      const pattern = args.pattern as string;
      const caseInsensitive = args.caseInsensitive as boolean || false;
      const maxResults = (args.maxResults as number) || 50;
      
      if (!existsSync(path)) {
        throw new Error(`File not found: ${path}`);
      }
      
      const matches = searchDocument(path, pattern, { caseInsensitive, maxResults });
      
      return {
        count: matches.length,
        matches: matches.map(m => ({
          lineNum: m.lineNum,
          line: m.line.trim(),
          match: m.match,
        })),
      };
    }
    
    case 'create_snapshot': {
      const path = resolve(args.path as string);
      const outputPath = args.outputPath 
        ? resolve(args.outputPath as string)
        : join(tmpdir(), `argus-snapshot-${Date.now()}.txt`);
      const extensions = args.extensions as string[] || config.defaults.snapshotExtensions;
      
      if (!existsSync(path)) {
        throw new Error(`Path not found: ${path}`);
      }
      
      const result = createSnapshot(path, outputPath, {
        extensions,
        excludePatterns: config.defaults.excludePatterns,
      });
      
      return {
        outputPath: result.outputPath,
        fileCount: result.fileCount,
        totalLines: result.totalLines,
        totalSize: result.totalSize,
      };
    }
    
    default:
      throw new Error(`Unknown tool: ${name}`);
  }
}

// MCP Protocol handlers
function handleInitialize(): MCPResponse['result'] {
  return {
    protocolVersion: '2024-11-05',
    capabilities: {
      tools: {},
    },
    serverInfo: {
      name: 'argus',
      version: '1.0.0',
    },
  };
}

function handleToolsList(): MCPResponse['result'] {
  return { tools: TOOLS };
}

async function handleToolsCall(params: { name: string; arguments: Record<string, unknown> }): Promise<MCPResponse['result']> {
  try {
    const result = await handleToolCall(params.name, params.arguments);
    return {
      content: [
        {
          type: 'text',
          text: typeof result === 'string' ? result : JSON.stringify(result, null, 2),
        },
      ],
    };
  } catch (error) {
    return {
      content: [
        {
          type: 'text',
          text: `Error: ${error instanceof Error ? error.message : String(error)}`,
        },
      ],
      isError: true,
    };
  }
}

// Main message handler
async function handleMessage(request: MCPRequest): Promise<MCPResponse | null> {
  try {
    let result: unknown;
    
    switch (request.method) {
      case 'initialize':
        result = handleInitialize();
        break;
      case 'tools/list':
        result = handleToolsList();
        break;
      case 'tools/call':
        result = await handleToolsCall(request.params as { name: string; arguments: Record<string, unknown> });
        break;
      case 'notifications/initialized':
      case 'notifications/cancelled':
        // Notifications don't get responses
        return null;
      default:
        // Check if it's a notification (no id = notification)
        if (request.id === undefined || request.id === null) {
          return null; // Don't respond to unknown notifications
        }
        return {
          jsonrpc: '2.0',
          id: request.id,
          error: {
            code: -32601,
            message: `Method not found: ${request.method}`,
          },
        };
    }
    
    return {
      jsonrpc: '2.0',
      id: request.id,
      result,
    };
  } catch (error) {
    return {
      jsonrpc: '2.0',
      id: request.id,
      error: {
        code: -32603,
        message: error instanceof Error ? error.message : String(error),
      },
    };
  }
}

// Start stdio server
const rl = createInterface({
  input: process.stdin,
  output: process.stdout,
  terminal: false,
});

rl.on('line', async (line) => {
  if (!line.trim()) return;
  
  try {
    const request = JSON.parse(line) as MCPRequest;
    const response = await handleMessage(request);
    
    // Only output if we have a response with a valid id
    // (notifications return null, and requests without id are notifications)
    if (response !== null && response.id !== undefined && response.id !== null) {
      console.log(JSON.stringify(response));
    }
  } catch (error) {
    // Only send parse errors if we can't parse at all
    // Don't include null id - that would be invalid
    const errorResponse = {
      jsonrpc: '2.0',
      id: 0, // Use 0 as fallback id for parse errors
      error: {
        code: -32700,
        message: 'Parse error',
      },
    };
    console.log(JSON.stringify(errorResponse));
  }
});


================================================================================
FILE: ./src/providers/anthropic.ts
================================================================================
/**
 * Anthropic Provider
 * 
 * Provider for Claude models via the Anthropic API.
 */

import { AIProvider, Message, CompletionOptions, CompletionResult, ProviderConfig } from './types.js';

export class AnthropicProvider implements AIProvider {
  name = 'Anthropic';
  private config: ProviderConfig;
  
  constructor(config: ProviderConfig) {
    if (!config.apiKey) {
      throw new Error('API key is required for Anthropic provider');
    }
    
    this.config = {
      ...config,
      baseUrl: config.baseUrl || 'https://api.anthropic.com',
      model: config.model || 'claude-sonnet-4-20250514',
    };
  }
  
  async complete(messages: Message[], options?: CompletionOptions): Promise<CompletionResult> {
    const endpoint = `${this.config.baseUrl}/v1/messages`;
    
    // Extract system message if present
    const systemMessage = messages.find(m => m.role === 'system');
    const nonSystemMessages = messages.filter(m => m.role !== 'system');
    
    const body = {
      model: this.config.model,
      max_tokens: options?.maxTokens ?? this.config.options?.max_tokens ?? 4096,
      ...(systemMessage && { system: systemMessage.content }),
      messages: nonSystemMessages.map(m => ({
        role: m.role,
        content: m.content,
      })),
      ...(options?.temperature !== undefined && { temperature: options.temperature }),
      ...(options?.stopSequences && { stop_sequences: options.stopSequences }),
    };
    
    const response = await fetch(endpoint, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-api-key': this.config.apiKey!,
        'anthropic-version': '2023-06-01',
      },
      body: JSON.stringify(body),
    });
    
    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Anthropic API error (${response.status}): ${errorText}`);
    }
    
    const data = await response.json() as {
      content: Array<{ type: string; text: string }>;
      stop_reason: string;
      usage: {
        input_tokens: number;
        output_tokens: number;
      };
    };
    
    const textContent = data.content
      .filter(c => c.type === 'text')
      .map(c => c.text)
      .join('');
    
    return {
      content: textContent,
      finishReason: data.stop_reason === 'end_turn' ? 'stop' : 
                    data.stop_reason === 'max_tokens' ? 'length' : 'error',
      usage: {
        promptTokens: data.usage.input_tokens,
        completionTokens: data.usage.output_tokens,
        totalTokens: data.usage.input_tokens + data.usage.output_tokens,
      },
    };
  }
  
  async healthCheck(): Promise<boolean> {
    try {
      const result = await this.complete([
        { role: 'user', content: 'Say "ok"' }
      ], { maxTokens: 10 });
      return result.content.length > 0;
    } catch {
      return false;
    }
  }
}

export function createAnthropicProvider(config: ProviderConfig): AIProvider {
  return new AnthropicProvider(config);
}


================================================================================
FILE: ./src/providers/index.ts
================================================================================
/**
 * Argus AI Providers
 * 
 * Factory for creating AI providers based on configuration.
 */

import { ArgusConfig, ProviderType, ProviderConfig } from '../core/config.js';
import { AIProvider } from './types.js';
import { createZAIProvider, createOpenAIProvider, createDeepSeekProvider } from './openai-compatible.js';
import { createOllamaProvider } from './ollama.js';
import { createAnthropicProvider } from './anthropic.js';

export type { AIProvider, Message, CompletionOptions, CompletionResult, ProviderConfig } from './types.js';
export { createZAIProvider, createOpenAIProvider, createDeepSeekProvider } from './openai-compatible.js';
export { createOllamaProvider, OllamaProvider } from './ollama.js';
export { createAnthropicProvider } from './anthropic.js';

/**
 * Create an AI provider from Argus configuration
 */
export function createProvider(config: ArgusConfig): AIProvider {
  const providerType = config.provider;
  const providerConfig = config.providers[providerType];
  
  if (!providerConfig) {
    throw new Error(`No configuration found for provider: ${providerType}`);
  }
  
  return createProviderByType(providerType, providerConfig);
}

/**
 * Create an AI provider by type and config
 */
export function createProviderByType(type: ProviderType, config: ProviderConfig): AIProvider {
  switch (type) {
    case 'zai':
      return createZAIProvider(config);
    case 'openai':
      return createOpenAIProvider(config);
    case 'deepseek':
      return createDeepSeekProvider(config);
    case 'ollama':
      return createOllamaProvider(config);
    case 'anthropic':
      return createAnthropicProvider(config);
    default:
      throw new Error(`Unknown provider type: ${type}`);
  }
}

/**
 * Get a human-readable name for a provider
 */
export function getProviderDisplayName(type: ProviderType): string {
  switch (type) {
    case 'zai':
      return 'ZAI (GLM)';
    case 'openai':
      return 'OpenAI';
    case 'deepseek':
      return 'DeepSeek';
    case 'ollama':
      return 'Ollama (Local)';
    case 'anthropic':
      return 'Anthropic (Claude)';
    default:
      return type;
  }
}

/**
 * List all available provider types
 */
export function listProviderTypes(): ProviderType[] {
  return ['zai', 'anthropic', 'openai', 'deepseek', 'ollama'];
}


================================================================================
FILE: ./src/providers/ollama.ts
================================================================================
/**
 * Ollama Provider
 * 
 * Provider for local Ollama models.
 */

import { AIProvider, Message, CompletionOptions, CompletionResult, ProviderConfig } from './types.js';

export class OllamaProvider implements AIProvider {
  name = 'Ollama';
  private config: ProviderConfig;
  
  constructor(config: ProviderConfig) {
    this.config = {
      ...config,
      baseUrl: config.baseUrl || 'http://localhost:11434',
      model: config.model || 'qwen2.5-coder:7b',
    };
  }
  
  async complete(messages: Message[], options?: CompletionOptions): Promise<CompletionResult> {
    const endpoint = `${this.config.baseUrl}/api/chat`;
    
    const body = {
      model: this.config.model,
      messages: messages.map(m => ({
        role: m.role,
        content: m.content,
      })),
      stream: false,
      options: {
        temperature: options?.temperature ?? this.config.options?.temperature ?? 0.2,
        num_ctx: this.config.options?.num_ctx ?? 8192,
      },
    };
    
    const response = await fetch(endpoint, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(body),
    });
    
    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Ollama API error (${response.status}): ${errorText}`);
    }
    
    const data = await response.json() as {
      message: { content: string };
      done: boolean;
      eval_count?: number;
      prompt_eval_count?: number;
    };
    
    return {
      content: data.message.content || '',
      finishReason: data.done ? 'stop' : 'error',
      usage: data.eval_count ? {
        promptTokens: data.prompt_eval_count || 0,
        completionTokens: data.eval_count,
        totalTokens: (data.prompt_eval_count || 0) + data.eval_count,
      } : undefined,
    };
  }
  
  async healthCheck(): Promise<boolean> {
    try {
      const response = await fetch(`${this.config.baseUrl}/api/tags`);
      if (!response.ok) return false;
      
      const data = await response.json() as { models: Array<{ name: string }> };
      const hasModel = data.models.some(m => 
        m.name === this.config.model || m.name.startsWith(this.config.model + ':')
      );
      
      return hasModel;
    } catch {
      return false;
    }
  }
  
  /**
   * List available models
   */
  async listModels(): Promise<string[]> {
    try {
      const response = await fetch(`${this.config.baseUrl}/api/tags`);
      if (!response.ok) return [];
      
      const data = await response.json() as { models: Array<{ name: string }> };
      return data.models.map(m => m.name);
    } catch {
      return [];
    }
  }
}

export function createOllamaProvider(config: ProviderConfig): OllamaProvider {
  return new OllamaProvider(config);
}


================================================================================
FILE: ./src/providers/openai-compatible.ts
================================================================================
/**
 * OpenAI-Compatible Provider
 * 
 * Works with OpenAI, ZAI (GLM), DeepSeek, and any OpenAI-compatible API.
 */

import { AIProvider, Message, CompletionOptions, CompletionResult, ProviderConfig } from './types.js';

export class OpenAICompatibleProvider implements AIProvider {
  name: string;
  private config: ProviderConfig;
  
  constructor(name: string, config: ProviderConfig) {
    this.name = name;
    this.config = config;
    
    if (!config.apiKey) {
      throw new Error(`API key is required for ${name} provider`);
    }
    
    if (!config.baseUrl) {
      throw new Error(`Base URL is required for ${name} provider`);
    }
  }
  
  async complete(messages: Message[], options?: CompletionOptions): Promise<CompletionResult> {
    const endpoint = `${this.config.baseUrl}/chat/completions`;
    
    const body = {
      model: this.config.model,
      messages: messages.map(m => ({
        role: m.role,
        content: m.content,
      })),
      temperature: options?.temperature ?? this.config.options?.temperature ?? 0.2,
      max_tokens: options?.maxTokens ?? this.config.options?.max_tokens ?? 4096,
      ...(options?.stopSequences && { stop: options.stopSequences }),
    };
    
    const response = await fetch(endpoint, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${this.config.apiKey}`,
      },
      body: JSON.stringify(body),
    });
    
    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`${this.name} API error (${response.status}): ${errorText}`);
    }
    
    const data = await response.json() as {
      choices: Array<{
        message: { content: string };
        finish_reason: string;
      }>;
      usage?: {
        prompt_tokens: number;
        completion_tokens: number;
        total_tokens: number;
      };
    };
    
    const choice = data.choices[0];
    
    return {
      content: choice.message.content || '',
      finishReason: choice.finish_reason === 'stop' ? 'stop' : 
                    choice.finish_reason === 'length' ? 'length' : 'error',
      usage: data.usage ? {
        promptTokens: data.usage.prompt_tokens,
        completionTokens: data.usage.completion_tokens,
        totalTokens: data.usage.total_tokens,
      } : undefined,
    };
  }
  
  async healthCheck(): Promise<boolean> {
    try {
      const result = await this.complete([
        { role: 'user', content: 'Say "ok"' }
      ], { maxTokens: 10 });
      return result.content.length > 0;
    } catch {
      return false;
    }
  }
}

/**
 * Create a provider for ZAI GLM models
 */
export function createZAIProvider(config: ProviderConfig): AIProvider {
  return new OpenAICompatibleProvider('ZAI', {
    ...config,
    baseUrl: config.baseUrl || 'https://api.z.ai/api/coding/paas/v4',
    model: config.model || 'glm-4.7',
  });
}

/**
 * Create a provider for OpenAI models
 */
export function createOpenAIProvider(config: ProviderConfig): AIProvider {
  return new OpenAICompatibleProvider('OpenAI', {
    ...config,
    baseUrl: config.baseUrl || 'https://api.openai.com/v1',
    model: config.model || 'gpt-4o',
  });
}

/**
 * Create a provider for DeepSeek models
 */
export function createDeepSeekProvider(config: ProviderConfig): AIProvider {
  return new OpenAICompatibleProvider('DeepSeek', {
    ...config,
    baseUrl: config.baseUrl || 'https://api.deepseek.com',
    model: config.model || 'deepseek-chat',
  });
}


================================================================================
FILE: ./src/providers/types.ts
================================================================================
/**
 * Argus AI Provider Interface
 * 
 * Defines the contract for AI providers used by the RLM engine.
 */

// Re-export ProviderConfig from core for convenience
export type { ProviderConfig } from '../core/config.js';

export interface Message {
  role: 'system' | 'user' | 'assistant';
  content: string;
}

export interface CompletionOptions {
  temperature?: number;
  maxTokens?: number;
  stopSequences?: string[];
}

export interface CompletionResult {
  content: string;
  finishReason: 'stop' | 'length' | 'error';
  usage?: {
    promptTokens: number;
    completionTokens: number;
    totalTokens: number;
  };
}

export interface AIProvider {
  name: string;
  
  /**
   * Generate a completion from the AI model
   */
  complete(messages: Message[], options?: CompletionOptions): Promise<CompletionResult>;
  
  /**
   * Check if the provider is properly configured and reachable
   */
  healthCheck(): Promise<boolean>;
}


================================================================================
FILE: ./tsup.config.ts
================================================================================
import { defineConfig } from 'tsup';

export default defineConfig([
  // Library build
  {
    entry: ['src/index.ts'],
    format: ['esm'],
    dts: true,
    splitting: false,
    sourcemap: true,
    clean: true,
  },
  // CLI builds with shebang
  {
    entry: {
      cli: 'src/cli.ts',
      mcp: 'src/mcp.ts',
    },
    format: ['esm'],
    splitting: false,
    sourcemap: true,
    shims: true,
    banner: {
      js: '#!/usr/bin/env node',
    },
  },
]);
